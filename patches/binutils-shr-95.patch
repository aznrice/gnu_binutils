bfd/

2007-01-23  H.J. Lu  <hongjiu.lu@intel.com>

	* elf-bfd.h (_bfd_elf_sharable_com_section): New.
	(_bfd_elf_add_sharable_symbol): Likewise.
	(_bfd_elf_sharable_section_from_bfd_section): Likewise.
	(_bfd_elf_sharable_symbol_processing): Likewise.
	(_bfd_elf_sharable_common_definition): Likewise.
	(_bfd_elf_sharable_common_section_index): Likewise.
	(_bfd_elf_sharable_common_section): Likewise.
	(_bfd_elf_sharable_merge_symbol): Likewise.

	* elf.c (special_sections_g): Add ".gnu.linkonce.shrb" and
	".gnu.linkonce.shrd".
	(special_sections_s): Add ".sharable_bss" and ".sharable_data".
	(get_program_header_size): Handle PT_GNU_SHR segment.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(assign_file_positions_for_load_sections): Likewise.

	* elf32-i386.c (elf_i386_link_hash_table): Add sdynsharablebss
	and srelsharablebss fields.
	(elf_i386_link_hash_table_create): Initialize sdynsharablebss
	and srelsharablebss.
	(elf_i386_create_dynamic_sections): Handle sdynsharablebss and
	srelsharablebss.
	(elf_i386_adjust_dynamic_symbol): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(elf_backend_add_symbol_hook): Defined.
	(elf_backend_section_from_bfd_section): Likewise.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_common_section_index): Likewise.
	(elf_backend_common_section): Likewise.
	(elf_backend_common_definition): Likewise.
	(elf_backend_merge_symbol): Likewise.

	* elf64-x86-64.c (elf_x86_64_link_hash_table): Add
	sdynsharablebss and srelsharablebss fields.
	(elf_x86_64_link_hash_table_create): Initialize sdynsharablebss
	and srelsharablebss.
	(elf_x86_64_create_dynamic_sections): Handle sdynsharablebss
	and srelsharablebss.
	(elf_x86_64_adjust_dynamic_symbol): Likewise.
	(elf_x86_64_size_dynamic_sections): Likewise.
	(elf_x86_64_finish_dynamic_symbol): Likewise.
	(elf_x86_64_add_symbol_hook): Handle sharable symbols.
	(elf_x86_64_elf_section_from_bfd_section): Likewise.
	(elf_x86_64_symbol_processing): Likewise.
	(elf_x86_64_merge_symbol): Likewise.
	(elf_x86_64_common_definition): Handle sharable sections.
	(elf_x86_64_common_section_index): Likewise.
	(elf_x86_64_common_section): Likewise.

	* elflink.c (_bfd_elf_create_dynamic_sections): Handle
	.dynsharablebss section.
	(_bfd_elf_sharable_com_section): New.
	(get_sharable_common_section): Likewise.
	(_bfd_elf_add_sharable_symbol): Likewise.
	(_bfd_elf_sharable_section_from_bfd_section): Likewise.
	(_bfd_elf_sharable_symbol_processing): Likewise.
	(_bfd_elf_sharable_common_definition): Likewise.
	(_bfd_elf_sharable_common_section_index): Likewise.
	(_bfd_elf_sharable_common_section): Likewise.
	(_bfd_elf_sharable_merge_symbol): Likewise.

	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Handle sharable
	symbols.
	(elf_backend_add_symbol_hook): Defined.
	(elf_backend_section_from_bfd_section): Likewise.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_common_section_index): Likewise.
	(elf_backend_common_section): Likewise.
	(elf_backend_common_definition): Likewise.
	(elf_backend_merge_symbol): Likewise.

binutils/

2007-01-04  H.J. Lu  <hongjiu.lu@intel.com>

	* readelf.c (dump_relocations): Handle sharable sections.
	(get_segment_type): Handle sharable segment.
	(get_symbol_index_type): Handle sharable sections.

gas/

2007-01-04  H.J. Lu  <hongjiu.lu@intel.com>

	* config/obj-elf.c (obj_elf_sharable_common): New.
	(elf_pseudo_table): Add "sharable_common".
	(obj_elf_change_section): Handle sharable sections.

include/

2007-01-23  H.J. Lu  <hongjiu.lu@intel.com>

	* bfdlink.h (bfd_link_info): Add sharable_sections.

include/elf/

2007-01-04  H.J. Lu  <hongjiu.lu@intel.com>

	* common.h (PT_GNU_SHR): New.
	(SHF_GNU_SHARABLE): Likewise.
	(SHN_GNU_SHARABLE_COMMON): Likewise.

ld/

2007-01-04  H.J. Lu  <hongjiu.lu@intel.com>

	* emulparams/elf64_ia64.sh (SHARABLE_SECTIONS): Set to yes.
	* emulparams/elf_i386.sh (SHARABLE_SECTIONS): Likewise.
	* emulparams/elf_x86_64.sh (SHARABLE_SECTIONS): Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_parse): Set
	link_info.sharable_sections based on $SHARABLE_SECTIONS.
	(gld${EMULATION_NAME}_place_orphan): Don't allow orphaned
	sharable sections.

	* ldmain.c (main): Initialize link_info.sharable_sections.
	* scripttempl/elf.sc: Support sharable sections.

diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index cc83588..de441d9 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -2089,6 +2089,28 @@ extern bfd_boolean bfd_elf_link_add_symbols
   (bfd *, struct bfd_link_info *);
 extern bfd_boolean _bfd_elf_add_dynamic_entry
   (struct bfd_link_info *, bfd_vma, bfd_vma);
+extern asection _bfd_elf_sharable_com_section;
+extern bfd_boolean _bfd_elf_add_sharable_symbol
+  (bfd *, struct bfd_link_info *, Elf_Internal_Sym *, const char **,
+   flagword *, asection **, bfd_vma *);
+extern bfd_boolean _bfd_elf_sharable_section_from_bfd_section
+  (bfd *, asection *, int *);
+extern void _bfd_elf_sharable_symbol_processing
+  (bfd *, asymbol *);
+extern bfd_boolean _bfd_elf_sharable_common_definition
+  (Elf_Internal_Sym *);
+extern unsigned int _bfd_elf_sharable_common_section_index
+  (asection *);
+extern asection *_bfd_elf_sharable_common_section
+  (asection *);
+extern bfd_boolean _bfd_elf_sharable_merge_symbol
+  (struct bfd_link_info *, struct elf_link_hash_entry **,
+   struct elf_link_hash_entry *, Elf_Internal_Sym *, asection **,
+   bfd_vma *, unsigned int *, bfd_boolean *, bfd_boolean *,
+   bfd_boolean *, bfd_boolean *, bfd_boolean *, bfd_boolean *,
+   bfd_boolean *, bfd_boolean *, bfd *, asection **,
+   bfd_boolean *, bfd_boolean *, bfd_boolean *, bfd_boolean *,
+   bfd *, asection **);
 
 extern bfd_boolean bfd_elf_link_record_dynamic_symbol
   (struct bfd_link_info *, struct elf_link_hash_entry *);
diff --git a/bfd/elf.c b/bfd/elf.c
index de0ab61..84be4ca 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -2090,6 +2090,8 @@ static const struct bfd_elf_special_section special_sections_g[] =
   { STRING_COMMA_LEN (".gnu.liblist"),     0, SHT_GNU_LIBLIST, SHF_ALLOC },
   { STRING_COMMA_LEN (".gnu.conflict"),    0, SHT_RELA,        SHF_ALLOC },
   { STRING_COMMA_LEN (".gnu.hash"),        0, SHT_GNU_HASH,    SHF_ALLOC },
+  { STRING_COMMA_LEN (".gnu.linkonce.shrb"), -2, SHT_NOBITS, SHF_ALLOC + SHF_WRITE + SHF_GNU_SHARABLE},
+  { STRING_COMMA_LEN (".gnu.linkonce.shrd"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_GNU_SHARABLE},
   { NULL,                        0,        0, 0,               0 }
 };
 
@@ -2144,6 +2146,8 @@ static const struct bfd_elf_special_section special_sections_s[] =
   /* See struct bfd_elf_special_section declaration for the semantics of
      this special case where .prefix_length != strlen (.prefix).  */
   { ".stabstr",			5,  3, SHT_STRTAB, 0 },
+  { STRING_COMMA_LEN (".sharable_bss"), -2, SHT_NOBITS, SHF_ALLOC + SHF_WRITE + SHF_GNU_SHARABLE},
+  { STRING_COMMA_LEN (".sharable_data"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_GNU_SHARABLE},
   { NULL,                       0,  0, 0,          0 }
 };
 
@@ -3589,6 +3593,32 @@ get_program_header_size (bfd *abfd, struct bfd_link_info *info)
 	}
     }
 
+  /* Check to see if we need a PT_GNU_SHR segment for sharable data
+     sections.  */
+  for (s = abfd->sections; s != NULL; s = s->next)
+    {
+      if ((elf_section_flags (s) & SHF_GNU_SHARABLE) != 0
+	  && elf_section_type (s) == SHT_PROGBITS)
+	{
+	  /* We need a PT_GNU_SHR segment.  */
+	  ++segs;
+	  break;
+	}
+    }
+
+  /* Check to see if we need a PT_GNU_SHR segment for sharable bss
+     sections.  */
+  for (s = abfd->sections; s != NULL; s = s->next)
+    {
+      if ((elf_section_flags (s) & SHF_GNU_SHARABLE) != 0
+	  && elf_section_type (s) == SHT_NOBITS)
+	{
+	  /* We need a PT_GNU_SHR segment.  */
+	  ++segs;
+	  break;
+	}
+    }
+
   /* Let the backend count up any program headers it might need.  */
   bed = get_elf_backend_data (abfd);
   if (bed->elf_backend_additional_program_headers)
@@ -3756,6 +3786,8 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
       bfd_boolean phdr_in_segment = TRUE;
       bfd_boolean writable;
       int tls_count = 0;
+      int sharable_data_count = 0, sharable_bss_count = 0;
+      asection *first_sharable_data = NULL, *first_sharable_bss = NULL;
       asection *first_tls = NULL;
       asection *dynsec, *eh_frame_hdr;
       bfd_size_type amt;
@@ -4059,6 +4091,22 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
 		first_tls = s;
 	      tls_count++;
 	    }
+	  if (elf_section_flags (s) & SHF_GNU_SHARABLE)
+	    {
+	      if (elf_section_type (s) == SHT_PROGBITS)
+		{
+		  if (! sharable_data_count)
+		    first_sharable_data = s;
+		  sharable_data_count++;
+		}
+	      else
+		{
+		  BFD_ASSERT (elf_section_type (s) == SHT_NOBITS);
+		  if (! sharable_bss_count)
+		    first_sharable_bss = s;
+		  sharable_bss_count++;
+		}
+	    }
 	}
 
       /* If there are any SHF_TLS output sections, add PT_TLS segment.  */
@@ -4086,6 +4134,60 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)
 	  pm = &m->next;
 	}
 
+      /* If there are any output SHF_GNU_SHARABLE data sections, add a
+	 PT_GNU_SHR segment.  */
+      if (sharable_data_count > 0)
+	{
+	  int j;
+
+	  amt = sizeof (struct elf_segment_map);
+	  amt += (sharable_data_count - 1) * sizeof (asection *);
+	  m = bfd_zalloc (abfd, amt);
+	  if (m == NULL)
+	    goto error_return;
+	  m->next = NULL;
+	  m->p_type = PT_GNU_SHR;
+	  m->count = sharable_data_count;
+	  /* Mandated PF_R.  */
+	  m->p_flags = PF_R;
+	  m->p_flags_valid = 1;
+	  for (j = 0; j < sharable_data_count; ++j)
+	    {
+	      m->sections[j] = first_sharable_data;
+	      first_sharable_data = first_sharable_data->next;
+	    }
+
+	  *pm = m;
+	   pm = &m->next;
+	}
+
+      /* If there are any output SHF_GNU_SHARABLE bss sections, add a
+	 PT_GNU_SHR segment.  */
+      if (sharable_bss_count > 0)
+	{
+	  int j;
+
+	  amt = sizeof (struct elf_segment_map);
+	  amt += (sharable_bss_count - 1) * sizeof (asection *);
+	  m = bfd_zalloc (abfd, amt);
+	  if (m == NULL)
+	    goto error_return;
+	  m->next = NULL;
+	  m->p_type = PT_GNU_SHR;
+	  m->count = sharable_bss_count;
+	  /* Mandated PF_R.  */
+	  m->p_flags = PF_R;
+	  m->p_flags_valid = 1;
+	  for (j = 0; j < sharable_bss_count; ++j)
+	    {
+	      m->sections[j] = first_sharable_bss;
+	      first_sharable_bss = first_sharable_bss->next;
+	    }
+
+	  *pm = m;
+	   pm = &m->next;
+	}
+
       /* If there is a .eh_frame_hdr section, throw in a PT_GNU_EH_FRAME
 	 segment.  */
       eh_frame_hdr = elf_tdata (abfd)->eh_frame_hdr;
@@ -4604,6 +4706,7 @@ assign_file_positions_for_load_sections (bfd *abfd,
 	  align = (bfd_size_type) 1 << bfd_get_section_alignment (abfd, sec);
 
 	  if ((p->p_type == PT_LOAD
+	       || p->p_type == PT_GNU_SHR
 	       || p->p_type == PT_TLS)
 	      && (this_hdr->sh_type != SHT_NOBITS
 		  || ((this_hdr->sh_flags & SHF_ALLOC) != 0
diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
index ae749c6..68cc630 100644
--- a/bfd/elf32-i386.c
+++ b/bfd/elf32-i386.c
@@ -686,6 +686,9 @@ struct elf_i386_link_hash_table
 
   /* Value used to fill the last word of the first plt entry.  */
   bfd_byte plt0_pad_byte;
+
+  asection *sdynsharablebss;
+  asection *srelsharablebss;
 };
 
 /* Get the i386 ELF linker hash table from a link_info structure.  */
@@ -827,6 +830,8 @@ elf_i386_link_hash_table_create (bfd *abfd)
   ret->srelplt2 = NULL;
   ret->plt0_pad_byte = 0;
   ret->tls_module_base = NULL;
+  ret->sdynsharablebss = NULL;
+  ret->srelsharablebss = NULL;
 
   ret->loc_hash_table = htab_try_create (1024,
 					 elf_i386_local_htab_hash,
@@ -875,10 +880,19 @@ elf_i386_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
 
   htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
   if (!info->shared)
-    htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");
+    {
+      htab->srelbss = bfd_get_section_by_name (dynobj, ".rel.bss");
+      htab->sdynsharablebss
+	= bfd_get_section_by_name (dynobj, ".dynsharablebss");
+      htab->srelsharablebss
+	= bfd_get_section_by_name (dynobj, ".rel.sharable_bss");
+    }
 
   if (!htab->sdynbss
-      || (!info->shared && !htab->srelbss))
+      || (!info->shared
+	  && (!htab->srelbss
+	      || !htab->sdynsharablebss
+	      || !htab->srelsharablebss)))
     abort ();
 
   if (htab->is_vxworks
@@ -2048,17 +2062,23 @@ elf_i386_adjust_dynamic_symbol (struct bfd_link_info *info,
      both the dynamic object and the regular object will refer to the
      same memory location for the variable.  */
 
+  s = htab->sdynbss;
+
   /* We must generate a R_386_COPY reloc to tell the dynamic linker to
      copy the initial value out of the dynamic object and into the
      runtime process image.  */
   if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
     {
-      htab->srelbss->size += sizeof (Elf32_External_Rel);
+      if (elf_section_flags (h->root.u.def.section) & SHF_GNU_SHARABLE)
+	{
+	  htab->srelsharablebss->size += sizeof (Elf32_External_Rel);
+	  s = htab->sdynsharablebss;
+	}
+      else
+	htab->srelbss->size += sizeof (Elf32_External_Rel);
       h->needs_copy = 1;
     }
 
-  s = htab->sdynbss;
-
   return _bfd_elf_adjust_dynamic_copy (h, s);
 }
 
@@ -2596,6 +2616,7 @@ elf_i386_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
 	  || s == htab->elf.sgotplt
 	  || s == htab->elf.iplt
 	  || s == htab->elf.igotplt
+	  || s == htab->sdynsharablebss
 	  || s == htab->sdynbss)
 	{
 	  /* Strip this section if we don't need it; see the
@@ -4388,21 +4409,27 @@ do_glob_dat:
     {
       Elf_Internal_Rela rel;
       bfd_byte *loc;
+      asection *s;
+
+      if (h->root.u.def.section == htab->sdynsharablebss)
+	s = htab->srelsharablebss;
+      else
+	s = htab->srelbss;
 
       /* This symbol needs a copy reloc.  Set it up.  */
 
       if (h->dynindx == -1
 	  || (h->root.type != bfd_link_hash_defined
 	      && h->root.type != bfd_link_hash_defweak)
-	  || htab->srelbss == NULL)
+	  || s == NULL)
 	abort ();
 
       rel.r_offset = (h->root.u.def.value
 		      + h->root.u.def.section->output_section->vma
 		      + h->root.u.def.section->output_offset);
       rel.r_info = ELF32_R_INFO (h->dynindx, R_386_COPY);
-      loc = htab->srelbss->contents;
-      loc += htab->srelbss->reloc_count++ * sizeof (Elf32_External_Rel);
+      loc = s->contents;
+      loc += s->reloc_count++ * sizeof (Elf32_External_Rel);
       bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
     }
 
@@ -4698,7 +4725,8 @@ elf_i386_add_symbol_hook (bfd * abfd,
       && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
     elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
 
-  return TRUE;
+  return _bfd_elf_add_sharable_symbol (abfd, info, sym, namep, flagsp,
+				       secp, valp);
 }
 
 #define TARGET_LITTLE_SYM		bfd_elf32_i386_vec
@@ -4751,6 +4779,19 @@ elf_i386_add_symbol_hook (bfd * abfd,
 #undef	elf_backend_post_process_headers
 #define	elf_backend_post_process_headers	_bfd_elf_set_osabi
 
+#define elf_backend_section_from_bfd_section \
+  _bfd_elf_sharable_section_from_bfd_section
+#define elf_backend_symbol_processing \
+  _bfd_elf_sharable_symbol_processing
+#define elf_backend_common_section_index \
+  _bfd_elf_sharable_common_section_index
+#define elf_backend_common_section \
+  _bfd_elf_sharable_common_section
+#define elf_backend_common_definition \
+  _bfd_elf_sharable_common_definition
+#define elf_backend_merge_symbol \
+  _bfd_elf_sharable_merge_symbol
+
 #include "elf32-target.h"
 
 /* FreeBSD support.  */
diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
index 3dd16ba..ce7ef97 100644
--- a/bfd/elf64-x86-64.c
+++ b/bfd/elf64-x86-64.c
@@ -514,6 +514,9 @@ struct elf_x86_64_link_hash_table
   /* The offset into sgot of the GOT entry used by the PLT entry
      above.  */
   bfd_vma tlsdesc_got;
+
+  asection *sdynsharablebss;
+  asection *srelsharablebss;
 };
 
 /* Get the x86-64 ELF linker hash table from a link_info structure.  */
@@ -654,6 +657,8 @@ elf_x86_64_link_hash_table_create (bfd *abfd)
   ret->tls_ld_got.refcount = 0;
   ret->sgotplt_jump_table_size = 0;
   ret->tls_module_base = NULL;
+  ret->sdynsharablebss = NULL;
+  ret->srelsharablebss = NULL;
 
   if (ABI_64_P (abfd))
     {
@@ -720,10 +725,19 @@ elf_x86_64_create_dynamic_sections (bfd *dynobj,
 
   htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
   if (!info->shared)
-    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
+    {
+      htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
+      htab->sdynsharablebss
+	= bfd_get_section_by_name (dynobj, ".dynsharablebss");
+      htab->srelsharablebss
+	= bfd_get_section_by_name (dynobj, ".rela.sharable_bss");
+    }
 
   if (!htab->sdynbss
-      || (!info->shared && !htab->srelbss))
+      || (!info->shared
+	  && (!htab->srelbss
+	      || !htab->sdynsharablebss
+	      || !htab->srelsharablebss)))
     abort ();
 
   return TRUE;
@@ -1925,6 +1939,8 @@ elf_x86_64_adjust_dynamic_symbol (struct bfd_link_info *info,
   if (htab == NULL)
     return FALSE;
 
+  s = htab->sdynbss;
+
   /* We must generate a R_X86_64_COPY reloc to tell the dynamic linker
      to copy the initial value out of the dynamic object and into the
      runtime process image.  */
@@ -1932,12 +1948,16 @@ elf_x86_64_adjust_dynamic_symbol (struct bfd_link_info *info,
     {
       const struct elf_backend_data *bed;
       bed = get_elf_backend_data (info->output_bfd);
-      htab->srelbss->size += bed->s->sizeof_rela;
+      if (elf_section_flags (h->root.u.def.section) & SHF_GNU_SHARABLE)
+	{
+	  htab->srelsharablebss->size += bed->s->sizeof_rela;
+	  s = htab->sdynsharablebss;
+	}
+      else
+	htab->srelbss->size += bed->s->sizeof_rela;
       h->needs_copy = 1;
     }
 
-  s = htab->sdynbss;
-
   return _bfd_elf_adjust_dynamic_copy (h, s);
 }
 
@@ -2458,6 +2478,7 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
 	  || s == htab->elf.sgotplt
 	  || s == htab->elf.iplt
 	  || s == htab->elf.igotplt
+	  || s == htab->sdynsharablebss
 	  || s == htab->sdynbss)
 	{
 	  /* Strip this section if we don't need it; see the
@@ -4031,13 +4052,19 @@ do_glob_dat:
   if (h->needs_copy)
     {
       Elf_Internal_Rela rela;
+      asection *s;
+
+      if (h->root.u.def.section == htab->sdynsharablebss)
+	s = htab->srelsharablebss;
+      else
+	s = htab->srelbss;
 
       /* This symbol needs a copy reloc.  Set it up.  */
 
       if (h->dynindx == -1
 	  || (h->root.type != bfd_link_hash_defined
 	      && h->root.type != bfd_link_hash_defweak)
-	  || htab->srelbss == NULL)
+	  || s == NULL)
 	abort ();
 
       rela.r_offset = (h->root.u.def.value
@@ -4045,7 +4072,7 @@ do_glob_dat:
 		       + h->root.u.def.section->output_offset);
       rela.r_info = htab->r_info (h->dynindx, R_X86_64_COPY);
       rela.r_addend = 0;
-      elf_append_rela (output_bfd, htab->srelbss, &rela);
+      elf_append_rela (output_bfd, s, &rela);
     }
 
   /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  SYM may
@@ -4349,7 +4376,8 @@ elf_x86_64_add_symbol_hook (bfd *abfd,
       && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
     elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
 
-  return TRUE;
+  return _bfd_elf_add_sharable_symbol (abfd, info, sym, namep, flagsp,
+				       secp, valp);
 }
 
 
@@ -4365,7 +4393,8 @@ elf_x86_64_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
       *index_return = SHN_X86_64_LCOMMON;
       return TRUE;
     }
-  return FALSE;
+  return _bfd_elf_sharable_section_from_bfd_section (abfd, sec,
+						     index_return);
 }
 
 /* Process a symbol.  */
@@ -4383,22 +4412,26 @@ elf_x86_64_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
       asym->value = elfsym->internal_elf_sym.st_size;
       /* Common symbol doesn't set BSF_GLOBAL.  */
       asym->flags &= ~BSF_GLOBAL;
+      return;
       break;
     }
+
+  _bfd_elf_sharable_symbol_processing (abfd, asym);
 }
 
 static bfd_boolean
 elf_x86_64_common_definition (Elf_Internal_Sym *sym)
 {
   return (sym->st_shndx == SHN_COMMON
-	  || sym->st_shndx == SHN_X86_64_LCOMMON);
+	  || sym->st_shndx == SHN_X86_64_LCOMMON
+	  || _bfd_elf_sharable_common_definition (sym));
 }
 
 static unsigned int
 elf_x86_64_common_section_index (asection *sec)
 {
   if ((elf_section_flags (sec) & SHF_X86_64_LARGE) == 0)
-    return SHN_COMMON;
+    return _bfd_elf_sharable_common_section_index (sec);
   else
     return SHN_X86_64_LCOMMON;
 }
@@ -4407,7 +4440,7 @@ static asection *
 elf_x86_64_common_section (asection *sec)
 {
   if ((elf_section_flags (sec) & SHF_X86_64_LARGE) == 0)
-    return bfd_com_section_ptr;
+    return _bfd_elf_sharable_common_section (sec);
   else
     return &_bfd_elf_large_com_section;
 }
@@ -4444,7 +4477,8 @@ elf_x86_64_merge_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
       && h->root.type == bfd_link_hash_common
       && !*newdyn
       && bfd_is_com_section (*sec)
-      && *oldsec != *sec)
+      && *oldsec != *sec
+      && _bfd_elf_sharable_common_section_index (*oldsec) == SHN_COMMON)
     {
       if (sym->st_shndx == SHN_COMMON
 	  && (elf_section_flags (*oldsec) & SHF_X86_64_LARGE) != 0)
@@ -4452,13 +4486,26 @@ elf_x86_64_merge_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
 	  h->root.u.c.p->section
 	    = bfd_make_section_old_way (oldbfd, "COMMON");
 	  h->root.u.c.p->section->flags = SEC_ALLOC;
+	  return TRUE;
 	}
       else if (sym->st_shndx == SHN_X86_64_LCOMMON
 	       && (elf_section_flags (*oldsec) & SHF_X86_64_LARGE) == 0)
-	*psec = *sec = bfd_com_section_ptr;
+	{
+	  *psec = *sec = bfd_com_section_ptr; 
+	  return TRUE;
+	}
     }
 
-  return TRUE;
+  return _bfd_elf_sharable_merge_symbol (info, sym_hash, h, sym,
+					 psec, pvalue, pold_alignment,
+					 skip, override,
+					 type_change_ok, size_change_ok,
+					 newdyn, newdef,
+					 newdyncommon, newweak,
+					 abfd, sec,
+					 olddyn, olddef,
+					 olddyncommon, oldweak,
+					 oldbfd, oldsec);
 }
 
 static int
diff --git a/bfd/elflink.c b/bfd/elflink.c
index 79256bf..906d323 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -383,6 +383,27 @@ _bfd_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
 	  if (s == NULL
 	      || ! bfd_set_section_alignment (abfd, s, bed->s->log_file_align))
 	    return FALSE;
+
+	  if (info->sharable_sections)
+	    {
+	      s = bfd_make_section (abfd, ".dynsharablebss");
+	      if (s == NULL
+		  || ! bfd_set_section_flags (abfd, s,
+					      (SEC_ALLOC
+					       | SEC_LINKER_CREATED)))
+		return FALSE;
+
+	      s = bfd_make_section (abfd,
+				    (bed->default_use_rela_p
+				     ? ".rela.sharable_bss"
+				     : ".rel.sharable_bss"));
+	      if (s == NULL
+		  || ! bfd_set_section_flags (abfd, s,
+					      flags | SEC_READONLY)
+		  || ! bfd_set_section_alignment (abfd, s,
+						  bed->s->log_file_align))
+		return FALSE;
+	    }
 	}
     }
 
@@ -12751,3 +12772,219 @@ elf_append_rel (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
   BFD_ASSERT (loc + bed->s->sizeof_rel <= s->contents + s->size);
   bed->s->swap_reloca_out (abfd, rel, loc);
 }
+
+asection _bfd_elf_sharable_com_section
+  = BFD_FAKE_SECTION (_bfd_elf_sharable_com_section, SEC_IS_COMMON,
+		      NULL, "SHARABLE_COMMON", 0);
+ 
+static asection *
+get_sharable_common_section (bfd *abfd)
+{
+  asection *scomm = bfd_get_section_by_name (abfd, "SHARABLE_COMMON");
+
+  if (scomm == NULL)
+    {
+      scomm = bfd_make_section_with_flags (abfd,
+					   "SHARABLE_COMMON",
+					   (SEC_ALLOC
+					    | SEC_IS_COMMON
+					    | SEC_LINKER_CREATED));
+      if (scomm == NULL)
+	return scomm;
+      elf_section_flags (scomm) |= SHF_GNU_SHARABLE;
+    }
+
+  return scomm;
+}
+
+bfd_boolean
+_bfd_elf_add_sharable_symbol (bfd *abfd ATTRIBUTE_UNUSED,
+			      struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			      Elf_Internal_Sym *sym,
+			      const char **namep ATTRIBUTE_UNUSED,
+			      flagword *flagsp ATTRIBUTE_UNUSED,
+			      asection **secp,
+			      bfd_vma *valp)
+{
+  asection *scomm;
+
+  switch (sym->st_shndx)
+    {
+    case SHN_GNU_SHARABLE_COMMON:
+      scomm = get_sharable_common_section (abfd);
+      if (scomm == NULL)
+	return FALSE;
+      *secp = scomm;
+      *valp = sym->st_size;
+      break;
+    }
+  return TRUE;
+}
+
+bfd_boolean
+_bfd_elf_sharable_section_from_bfd_section
+  (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, int *index_return)
+{
+  if (sec == &_bfd_elf_sharable_com_section)
+    {
+      *index_return = SHN_GNU_SHARABLE_COMMON;
+      return TRUE;
+    }
+  return FALSE;
+}
+
+void
+_bfd_elf_sharable_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
+				     asymbol *asym)
+{
+  elf_symbol_type *elfsym = (elf_symbol_type *) asym;
+
+  switch (elfsym->internal_elf_sym.st_shndx)
+    {
+    case SHN_GNU_SHARABLE_COMMON:
+      asym->section = &_bfd_elf_sharable_com_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      asym->flags &= ~BSF_GLOBAL;
+      break;
+    }
+}
+
+bfd_boolean
+_bfd_elf_sharable_common_definition (Elf_Internal_Sym *sym)
+{
+  return (sym->st_shndx == SHN_COMMON
+	  || sym->st_shndx == SHN_GNU_SHARABLE_COMMON);
+}
+
+unsigned int
+_bfd_elf_sharable_common_section_index (asection *sec)
+{
+  if ((elf_section_flags (sec) & SHF_GNU_SHARABLE) == 0)
+    return SHN_COMMON;
+  else
+    return SHN_GNU_SHARABLE_COMMON;
+}
+
+asection *
+_bfd_elf_sharable_common_section (asection *sec)
+{
+  if ((elf_section_flags (sec) & SHF_GNU_SHARABLE) == 0)
+    return bfd_com_section_ptr;
+  else
+    return &_bfd_elf_sharable_com_section;
+}
+
+bfd_boolean
+_bfd_elf_sharable_merge_symbol
+  (struct bfd_link_info *info ATTRIBUTE_UNUSED,
+   struct elf_link_hash_entry **sym_hash ATTRIBUTE_UNUSED,
+   struct elf_link_hash_entry *h,
+   Elf_Internal_Sym *sym ATTRIBUTE_UNUSED,
+   asection **psec,
+   bfd_vma *pvalue ATTRIBUTE_UNUSED,
+   unsigned int *pold_alignment ATTRIBUTE_UNUSED,
+   bfd_boolean *skip ATTRIBUTE_UNUSED,
+   bfd_boolean *override ATTRIBUTE_UNUSED,
+   bfd_boolean *type_change_ok ATTRIBUTE_UNUSED,
+   bfd_boolean *size_change_ok ATTRIBUTE_UNUSED,
+   bfd_boolean *newdef ATTRIBUTE_UNUSED,
+   bfd_boolean *newdyn,
+   bfd_boolean *newdyncommon ATTRIBUTE_UNUSED,
+   bfd_boolean *newweak ATTRIBUTE_UNUSED,
+   bfd *abfd,
+   asection **sec,
+   bfd_boolean *olddef ATTRIBUTE_UNUSED,
+   bfd_boolean *olddyn,
+   bfd_boolean *olddyncommon ATTRIBUTE_UNUSED,
+   bfd_boolean *oldweak ATTRIBUTE_UNUSED,
+   bfd *oldbfd,
+   asection **oldsec)
+{
+  /* Check sharable symbol.  If one is undefined, it is OK.  */
+  if (*oldsec && !bfd_is_und_section (*sec))
+    {
+      bfd_boolean sharable, oldsharable;
+     
+      sharable = (elf_section_data (*sec)
+		  && (elf_section_flags (*sec) & SHF_GNU_SHARABLE));
+      oldsharable = (elf_section_data (*oldsec)
+		     && (elf_section_flags (*oldsec)
+			 & SHF_GNU_SHARABLE));
+
+      if (sharable != oldsharable)
+	{
+	  bfd *nsbfd, *sbfd;
+	  asection *nssec, *ssec;
+	  bfd_boolean nsdyn, sdyn, nsdef, sdef;
+
+	  if (oldsharable)
+	    {
+	      sbfd = oldbfd;
+	      nsbfd = abfd;
+	      ssec = *oldsec;
+	      nssec = *sec;
+	      sdyn = *olddyn;
+	      nsdyn = *newdyn;
+	      sdef = *olddef;
+	      nsdef = *newdef;
+	    }
+	  else
+	    {
+	      sbfd = abfd;
+	      nsbfd = oldbfd;
+	      ssec = *sec;
+	      nssec = *oldsec;
+	      sdyn = *newdyn;
+	      nsdyn = *olddyn;
+	      sdef = *newdef;
+	      nsdef = *olddef;
+	    }
+
+	  if (sdef && !sdyn)
+	    {
+	      /* If the sharable definition comes from a relocatable
+		 file, it will override the non-sharable one in DSO. */
+	      return TRUE;
+	    }
+	  else if (!nsdef
+		   && !nsdyn
+		   && (h->root.type == bfd_link_hash_common
+		       || bfd_is_com_section (nssec)))
+	    {
+	      asection *scomm;
+
+	      /* When the non-sharable common symbol in a relocatable
+		 file, we can turn it into sharable.  If the sharable
+		 symbol isn't common, the non-sharable common symbol
+		 will be overidden.  We only need to handle the
+		 sharable common symbol and the non-sharable common
+		 symbol.  We just turn the non-sharable common symbol
+		 into the sharable one. */
+	      if (sym->st_shndx == SHN_GNU_SHARABLE_COMMON)
+		{
+		  scomm = get_sharable_common_section (oldbfd);
+		  if (scomm == NULL)
+		    return FALSE;
+		  h->root.u.c.p->section = scomm;
+		}
+	      else
+		{
+		  scomm = get_sharable_common_section (abfd);
+		  if (scomm == NULL)
+		    return FALSE;
+		  *psec = *sec = scomm;
+		}
+
+	      return TRUE;
+	    }
+
+	  (*_bfd_error_handler)
+	    (_("%s: sharable symbol in %B section %A mismatches non-shrable symbol in %B section %A"),
+	     sbfd, ssec, nsbfd, nssec, h->root.root.string);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+	}
+    }
+
+  return TRUE;
+}
diff --git a/bfd/elfxx-ia64.c b/bfd/elfxx-ia64.c
index d42ad89..03de115 100644
--- a/bfd/elfxx-ia64.c
+++ b/bfd/elfxx-ia64.c
@@ -1576,7 +1576,8 @@ elfNN_ia64_add_symbol_hook (bfd *abfd,
       *valp = sym->st_size;
     }
 
-  return TRUE;
+  return _bfd_elf_add_sharable_symbol (abfd, info, sym, namep, flagsp,
+				       secp, valp);
 }
 
 /* Return the number of additional phdrs we will need.  */
@@ -6068,6 +6069,19 @@ elfNN_vms_close_and_cleanup (bfd *abfd)
 #define elf_backend_special_sections	elfNN_ia64_special_sections
 #define elf_backend_default_execstack	0
 
+#define elf_backend_section_from_bfd_section \
+  _bfd_elf_sharable_section_from_bfd_section
+#define elf_backend_symbol_processing \
+  _bfd_elf_sharable_symbol_processing
+#define elf_backend_common_section_index \
+  _bfd_elf_sharable_common_section_index
+#define elf_backend_common_section \
+  _bfd_elf_sharable_common_section
+#define elf_backend_common_definition \
+  _bfd_elf_sharable_common_definition
+#define elf_backend_merge_symbol \
+  _bfd_elf_sharable_merge_symbol
+
 /* FIXME: PR 290: The Intel C compiler generates SHT_IA_64_UNWIND with
    SHF_LINK_ORDER. But it doesn't set the sh_link or sh_info fields.
    We don't want to flood users with so many error messages. We turn
diff --git a/binutils/readelf.c b/binutils/readelf.c
index b8ab55b..67a28e4 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -1300,6 +1300,8 @@ dump_relocations (FILE * file,
 			sec_name = "ABS";
 		      else if (psym->st_shndx == SHN_COMMON)
 			sec_name = "COMMON";
+		      else if (psym->st_shndx == SHN_GNU_SHARABLE_COMMON)
+			sec_name = "GNU_SHARABLE_COMMON";
 		      else if (elf_header.e_machine == EM_MIPS
 			       && psym->st_shndx == SHN_MIPS_SCOMMON)
 			sec_name = "SCOMMON";
@@ -2750,6 +2752,7 @@ get_segment_type (unsigned long p_type)
     case PT_SHLIB:	return "SHLIB";
     case PT_PHDR:	return "PHDR";
     case PT_TLS:	return "TLS";
+    case PT_GNU_SHR:	return "GNU_SHR";
 
     case PT_GNU_EH_FRAME:
 			return "GNU_EH_FRAME";
@@ -8394,6 +8397,8 @@ get_symbol_index_type (unsigned int type)
     case SHN_UNDEF:	return "UND";
     case SHN_ABS:	return "ABS";
     case SHN_COMMON:	return "COM";
+    case SHN_GNU_SHARABLE_COMMON:
+			return "GNU_SHARABLE_COM";
     default:
       if (type == SHN_IA_64_ANSI_COMMON
 	  && elf_header.e_machine == EM_IA_64
diff --git a/gas/config/obj-elf.c b/gas/config/obj-elf.c
index c6dc8d6..8411acd 100644
--- a/gas/config/obj-elf.c
+++ b/gas/config/obj-elf.c
@@ -73,6 +73,7 @@ static void obj_elf_symver (int);
 static void obj_elf_subsection (int);
 static void obj_elf_popsection (int);
 static void obj_elf_tls_common (int);
+static void obj_elf_sharable_common (int);
 static void obj_elf_lcomm (int);
 static void obj_elf_struct (int);
 
@@ -130,6 +131,8 @@ static const pseudo_typeS elf_pseudo_table[] =
 
   {"tls_common", obj_elf_tls_common, 0},
 
+  {"sharable_common", obj_elf_sharable_common, 0},
+
   /* End sentinel.  */
   {NULL, NULL, 0},
 };
@@ -385,6 +388,39 @@ obj_elf_tls_common (int ignore ATTRIBUTE_UNUSED)
 }
 
 static void
+obj_elf_sharable_common (int ignore ATTRIBUTE_UNUSED)
+{
+  static segT sharable_bss_section;
+  asection *saved_com_section_ptr = elf_com_section_ptr;
+  asection *saved_bss_section = bss_section;
+
+  if (sharable_bss_section == NULL)
+    {
+      flagword applicable;
+      segT seg = now_seg;
+      subsegT subseg = now_subseg;
+
+      /* The .sharable_bss section is for local .sharable_common
+	 symbols.  */
+      sharable_bss_section = subseg_new (".sharable_bss", 0);
+      applicable = bfd_applicable_section_flags (stdoutput);
+      bfd_set_section_flags (stdoutput, sharable_bss_section,
+			     applicable & SEC_ALLOC);
+      seg_info (sharable_bss_section)->bss = 1;
+
+      subseg_set (seg, subseg);
+    }
+
+  elf_com_section_ptr = &_bfd_elf_sharable_com_section;
+  bss_section = sharable_bss_section;
+
+  s_comm_internal (0, elf_common_parse);
+
+  elf_com_section_ptr = saved_com_section_ptr;
+  bss_section = saved_bss_section;
+}
+
+static void
 obj_elf_lcomm (int ignore ATTRIBUTE_UNUSED)
 {
   symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);
@@ -604,11 +640,17 @@ obj_elf_change_section (const char *name,
 
 		 .section .lbss,"aw",@progbits
 
+		 "@progbits" is incorrect.  Also for sharable bss
+		 sections, gcc, as of 2005-07-06, will emit
+
+		 .section .sharable_bss,"aw",@progbits
+
 		 "@progbits" is incorrect.  */
 #ifdef TC_I386
 	      && (bed->s->arch_size != 64
 		  || !(ssect->attr & SHF_X86_64_LARGE))
 #endif
+	      && !(ssect->attr & SHF_GNU_SHARABLE)
 	      && ssect->type != SHT_INIT_ARRAY
 	      && ssect->type != SHT_FINI_ARRAY
 	      && ssect->type != SHT_PREINIT_ARRAY)
diff --git a/include/bfdlink.h b/include/bfdlink.h
index 0d6e9f8..d3c13f6 100644
--- a/include/bfdlink.h
+++ b/include/bfdlink.h
@@ -354,6 +354,9 @@ struct bfd_link_info
   /* Non-NULL if .note.gnu.build-id section should be created.  */
   char *emit_note_gnu_build_id;
 
+  /* TRUE if sharables sections may be created.  */
+  unsigned int sharable_sections: 1;
+
   /* What to do with unresolved symbols in an object file.
      When producing executables the default is GENERATE_ERROR.
      When producing shared libraries the default is IGNORE.  The
diff --git a/include/elf/common.h b/include/elf/common.h
index 01c519d..3f76440 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -429,6 +429,7 @@
 #define PT_SUNW_EH_FRAME PT_GNU_EH_FRAME      /* Solaris uses the same value */
 #define PT_GNU_STACK	(PT_LOOS + 0x474e551) /* Stack flags */
 #define PT_GNU_RELRO	(PT_LOOS + 0x474e552) /* Read-only after relocation */
+#define PT_GNU_SHR	(PT_LOOS + 0x474e554) /* Sharable segment */
 
 /* Program segment permissions, in program header p_flags field.  */
 
@@ -511,6 +512,8 @@
 					   are not to be further
 					   relocated.  */
 
+#define SHF_GNU_SHARABLE 0x01000000	/* sharable section */
+
 /* Values of note segment descriptor types for core files.  */
 
 #define NT_PRSTATUS	1		/* Contains copy of prstatus struct */
@@ -657,6 +660,9 @@
 #define STT_LOPROC	13		/* Processor-specific semantics */
 #define STT_HIPROC	15		/* Processor-specific semantics */
 
+/* Associated symbol is in common sharable */
+#define SHN_GNU_SHARABLE_COMMON (SHN_LOOS + 10)
+
 /* The following constants control how a symbol may be accessed once it has
    become part of an executable or shared library.  */
 
diff --git a/ld/emulparams/elf64_ia64.sh b/ld/emulparams/elf64_ia64.sh
index 7e5e54d..d8cf531 100644
--- a/ld/emulparams/elf64_ia64.sh
+++ b/ld/emulparams/elf64_ia64.sh
@@ -37,3 +37,4 @@ OTHER_READONLY_SECTIONS="${OTHER_READONLY_SECTIONS}
 # .dtors.  They have to be next to .sbss/.sbss2/.sdata/.sdata2.
 SMALL_DATA_CTOR=" "
 SMALL_DATA_DTOR=" "
+SHARABLE_SECTIONS=yes
diff --git a/ld/emulparams/elf_i386.sh b/ld/emulparams/elf_i386.sh
index d480811..8268106 100644
--- a/ld/emulparams/elf_i386.sh
+++ b/ld/emulparams/elf_i386.sh
@@ -13,3 +13,4 @@ GENERATE_PIE_SCRIPT=yes
 NO_SMALL_DATA=yes
 SEPARATE_GOTPLT=12
 IREL_IN_PLT=
+SHARABLE_SECTIONS=yes
diff --git a/ld/emulparams/elf_x86_64.sh b/ld/emulparams/elf_x86_64.sh
index 0e93ad8..c82d6c9 100644
--- a/ld/emulparams/elf_x86_64.sh
+++ b/ld/emulparams/elf_x86_64.sh
@@ -15,6 +15,7 @@ NO_SMALL_DATA=yes
 LARGE_SECTIONS=yes
 SEPARATE_GOTPLT=24
 IREL_IN_PLT=
+SHARABLE_SECTIONS=yes
 
 if [ "x${host}" = "x${target}" ]; then
   case " $EMULATION_LIBPATH " in
diff --git a/ld/emultempl/elf32.em b/ld/emultempl/elf32.em
index 9120f85..ca86c7c 100644
--- a/ld/emultempl/elf32.em
+++ b/ld/emultempl/elf32.em
@@ -103,6 +103,7 @@ gld${EMULATION_NAME}_before_parse (void)
   ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
   config.dynamic_link = ${DYNAMIC_LINK-TRUE};
   config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
+  link_info.sharable_sections = `if test "$SHARABLE_SECTIONS" = "yes" ; then echo TRUE ; else echo FALSE ; fi`;
 }
 
 EOF
@@ -1812,6 +1813,12 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
   int iself = s->owner->xvec->flavour == bfd_target_elf_flavour;
   unsigned int sh_type = iself ? elf_section_type (s) : SHT_NULL;
 
+  /* Orphaned sharable sections won't have correct page
+     requirements.  */
+  if (elf_section_flags (s) & SHF_GNU_SHARABLE)
+    einfo ("%F%P: unable to place orphaned sharable section %A (%B)\n",
+	   s, s->owner);
+
   if (! link_info.relocatable
       && link_info.combreloc
       && (s->flags & SEC_ALLOC))
diff --git a/ld/ldmain.c b/ld/ldmain.c
index 5530dca..6d88479 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -282,6 +282,7 @@ main (int argc, char **argv)
   link_info.pei386_auto_import = -1;
   link_info.spare_dynamic_tags = 5;
   link_info.path_separator = ':';
+  link_info.sharable_sections = FALSE;
 
   ldfile_add_arch ("");
   emulation = get_emulation (argc, argv);
diff --git a/ld/scripttempl/elf.sc b/ld/scripttempl/elf.sc
index 37f7667..18d456d 100644
--- a/ld/scripttempl/elf.sc
+++ b/ld/scripttempl/elf.sc
@@ -290,6 +290,40 @@ STACK="  .stack        ${RELOCATING-0}${RELOCATING+${STACK_ADDR}} :
     ${RELOCATING+${USER_LABEL_PREFIX}_stack = .;}
     *(.stack)
   }"
+test "${SHARABLE_SECTIONS}" = "yes" && OTHER_READWRITE_SECTIONS="
+  ${OTHER_READWRITE_SECTIONS}
+  /* Sharable data sections.  */
+  .sharable_data ${RELOCATING-0} : ${RELOCATING+ALIGN(${MAXPAGESIZE})}
+  {
+    ${RELOCATING+PROVIDE_HIDDEN (__sharable_data_start = .);}
+    *(.sharable_data${RELOCATING+ .sharable_data.* .gnu.linkonce.shrd.*})
+    /* Align here to ensure that the sharable data section ends at the
+       page boundary.  */
+    ${RELOCATING+. = ALIGN(. != 0 ? ${MAXPAGESIZE} : 1);}
+    ${RELOCATING+PROVIDE_HIDDEN (__sharable_data_end = .);}
+  }
+"
+test "${SHARABLE_SECTIONS}" = "yes" && OTHER_BSS_SECTIONS="
+  ${OTHER_BSS_SECTIONS}
+  /* Sharable bss sections  */
+  .sharable_bss ${RELOCATING-0} : ${RELOCATING+ALIGN(${MAXPAGESIZE})}
+  {
+    ${RELOCATING+PROVIDE_HIDDEN (__sharable_bss_start = .);}
+    *(.dynsharablebss)
+    *(.sharable_bss${RELOCATING+ .sharable_bss.* .gnu.linkonce.shrb.*}) 
+    *(SHARABLE_COMMON)
+    /* Align here to ensure that the sharable bss section ends at the
+       page boundary.  */
+    ${RELOCATING+. = ALIGN(. != 0 ? ${MAXPAGESIZE} : 1);}
+    ${RELOCATING+PROVIDE_HIDDEN (__sharable_bss_end = .);}
+  }
+"
+test "${SHARABLE_SECTIONS}" = "yes" && REL_SHARABLE="
+  .rel.sharable_data	${RELOCATING-0} : { *(.rel.sharable_data${RELOCATING+ .rel.sharable_data.* .rel.gnu.linkonce.shrd.*}) }
+  .rela.sharable_data	${RELOCATING-0} : { *(.rela.sharable_data${RELOCATING+ .rela.sharable_data.* .rela.gnu.linkonce.shrd.*}) }
+  .rel.sharable_bss	${RELOCATING-0} : { *(.rel.sharable_bss${RELOCATING+ .rel.sharable_bss.* .rel.gnu.linkonce.shrb.*}) }
+  .rela.sharable_bss	${RELOCATING-0} : { *(.rela.sharable_bss${RELOCATING+ .rela.sharable_bss.* .rela.gnu.linkonce.shrb.*}) }
+"
 
 TEXT_START_ADDR="SEGMENT_START(\"text-segment\", ${TEXT_START_ADDR})"
 SHLIB_TEXT_START_ADDR="SEGMENT_START(\"text-segment\", ${SHLIB_TEXT_START_ADDR:-0})"
@@ -370,6 +404,7 @@ eval $COMBRELOCCAT <<EOF
   .rel.got      ${RELOCATING-0} : { *(.rel.got) }
   .rela.got     ${RELOCATING-0} : { *(.rela.got) }
   ${OTHER_GOT_RELOC_SECTIONS}
+  ${REL_SHARABLE}
   ${REL_SDATA}
   ${REL_SBSS}
   ${REL_SDATA2}
