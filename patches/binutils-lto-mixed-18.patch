bfd/

2012-06-28  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/14272
	* elflink.c (_bfd_elf_fix_symbol_flags): Mark the plugin symbol
	undefined if it is referenced from a non-IR file.

2012-06-04  H.J. Lu  <hongjiu.lu@intel.com>

	* plugin.c (add_symbols): Set tdata.plugin_data before calling
	bfd_plugin_get_symbols_in_object_only.

2011-10-16  H.J. Lu  <hongjiu.lu@intel.com>

	* plugin.c (add_symbols): Call
	bfd_plugin_get_symbols_in_object_only.
	(bfd_plugin_get_symtab_upper_bound): Don't call
	bfd_plugin_get_symbols_in_object_only.

2011-10-16  H.J. Lu  <hongjiu.lu@intel.com>

	* plugin.c (bfd_plugin_get_symbols_in_object_only): Optimized.

2011-10-16  H.J. Lu  <hongjiu.lu@intel.com>

	* plugin.c (bfd_plugin_get_symbols_in_object_only): Properly
	remove the object only section file.

2011-10-15  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/13298
	* opncls.c (bfd_extract_object_only_section): New.

	* plugin.c (add_symbols): Initialize object_only_syms and
	object_only_nsyms.
	(bfd_plugin_fake_text_section): New.
	(bfd_plugin_fake_common_section): Likewise.
	(bfd_plugin_get_symbols_in_object_only): Likewise.
	(bfd_plugin_get_symtab_upper_bound): Call
	bfd_plugin_get_symbols_in_object_only and add symbols from
	object only section.
	(bfd_plugin_canonicalize_symtab): Remove fake_section and
	fake_common_section.  Use bfd_plugin_fake_text_section and
	bfd_plugin_fake_common_section.  Set udata.p to NULL.  Copy
	symbols from object only section.

	* plugin.h (plugin_data_struct): Add object_only_nsyms and
	object_only_syms.

	* bfd-in2.h: Regenerated.

2011-05-14  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/12758
	* elflink.c (elf_link_add_archive_symbols): Don't load the IR
	archive member twice.

2011-04-19  H.J. Lu  <hongjiu.lu@intel.com>

	* bfd.c (bfd_lto_object_type): New.
	(bfd): Add object_only_section and lto_type.
	(bfd_group_signature): New.

	* elf.c (special_sections_g): Add .gnu_object_only.

	* format.c (bfd_set_lto_type): New.
	(bfd_check_format_matches): Use it.

	* section.c (GNU_OBJECT_ONLY_SECTION_NAME): New.

	* bfd-in2.h: Regenerated.

binutils/

2011-04-19  H.J. Lu  <hongjiu.lu@intel.com>

	* objcopy.c (group_signature): Removed.
	(is_strip_section): Replace group_signature with
	bfd_group_signature.
	(setup_section): Likewise.

	* readelf.c (get_section_type_name): Handle SHT_GNU_OBJECT_ONLY.

gas/testsuite/

2011-04-19  H.J. Lu  <hongjiu.lu@intel.com>

	* gas/elf/section9.s: Add the .gnu_object_only test.
	* gas/elf/section9.d: Updated.

include/

2011-04-19  H.J. Lu  <hongjiu.lu@intel.com>

	* bfdlink.h (bfd_link_info): Add emit_gnu_object_only and
	emitting_gnu_object_only.

include/elf/

2011-04-19  H.J. Lu  <hongjiu.lu@intel.com>

	* common.h (SHT_GNU_OBJECT_ONLY): New.

ld/

2011-10-15  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/13298
	* ldlang.c (cmdline_extract_object_only_section): Call
	bfd_extract_object_only_section.

2011-05-17  H.J. Lu  <hongjiu.lu@intel.com>

	* ldlang.c (cmdline_remove_object_only_files): Return if
	ENABLE_PLUGINS is undefined or plugin_save_temps is true.

2011-05-15  H.J. Lu  <hongjiu.lu@intel.com>

	* ldlex.h (option_values): Add OPTION_PLUGIN_SAVE_TEMPS.
	* lexsup.c (ld_options): Add -plugin-save-temps.
	(parse_args): Handle OPTION_PLUGIN_SAVE_TEMPS.

	* plugin.c (plugin_save_temps): New.
	(plugin_call_cleanup): Don't call plugin cleanup_handler if
	plugin_save_temps is true.

	* plugin.h (plugin_save_temps): New.

2011-05-14  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/12760
	* ldmain.c (warning_callback): Don't warn plugin dummy.

2011-04-19  H.J. Lu  <hongjiu.lu@intel.com>

	* emultempl/alphaelf.em (alpha_finish): Replace finish_default
	with gld${EMULATION_NAME}_finish.

	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Renamed
	to ...
	(arm_finish): This.  Replace finish_default with
	gld${EMULATION_NAME}_finish.
	(LDEMUL_FINISH): Set to arm_finish.

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): New.
	(orphan_init_done): Likewise.
	(ld_${EMULATION_NAME}_emulation): Use gld${EMULATION_NAME}_finish.
	(gld${EMULATION_NAME}_place_orphan): Initialize hold.

	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_finish): Renamed
	to ...
	(ppc_finish): This.  Replace finish_default with
	gld${EMULATION_NAME}_finish.
	(LDEMUL_FINISH): Set to ppc_finish.

	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Renamed
	to ...
	(spu_finish): This.  Replace finish_default with
	gld${EMULATION_NAME}_finish.
	(LDEMUL_FINISH): Set to spu_finish.

	* ldfile.c (ldfile_try_open_bfd): Call
	cmdline_check_object_only_section.

	* ldlang.c: Include "ldwrite.h" and elf-bfd.h.
	* ldlang.c (cmdline_object_only_file_list): New.
	(cmdline_object_only_archive_list): Likewise.
	(cmdline_temp_object_only_list): Likewise.
	(cmdline_lists_init): Likewise.
	(cmdline_list_new): Likewise.
	(cmdline_list_append): Likewise.
	(print_cmdline_list): Likewise.
	(cmdline_on_object_only_archive_list_p): Likewise.
	(cmdline_object_only_list_append): Likewise.
	(cmdline_get_object_only_input_files): Likewise.
	(cmdline_arg): Likewise.
	(setup_section): Likewise.
	(copy_section): Likewise.
	(cmdline_fopen_temp): Likewise.
	(cmdline_add_object_only_section): Likewise.
	(cmdline_emit_object_only_section): Likewise.
	(cmdline_extract_object_only_section): Likewise.
	(cmdline_check_object_only_section): Likewise.
	(cmdline_remove_object_only_files): Likewise.
	(lang_init): Take a bfd_boolean argument to supprt object-only
	output.  Call cmdline_lists_init.
	(load_symbols): Call cmdline_on_object_only_archive_list_p
	to check if an archive member should be loaded.
	(lang_process): Handle object-only link.

	* ldlang.h (lang_init): Take a bfd_boolean argument.
	(cmdline_enum_type): New.
	(cmdline_header_type): Likewise.
	(cmdline_file_type): Likewise.
	(cmdline_bfd_type): Likewise.
	(cmdline_union_type): Likewise.
	(cmdline_list_type): Likewise.
	(cmdline_emit_object_only_section): Likewise.
	(cmdline_check_object_only_section): Likewise.
	(cmdline_remove_object_only_files): Likewise.

	* ldmain.c (main): Call xatexit with
	cmdline_remove_object_only_files.  Pass FALSE to lang_init.
	Use ld_parse_linker_script.  Set link_info.output_bfd to NULL
	after close.  Call cmdline_emit_object_only_section if needed.
	(add_archive_element): Call cmdline_check_object_only_section.
	(ld_parse_linker_script): New.

	* ldmain.h (ld_parse_linker_script): New.

	* plugin.c (plugin_opt_plugin_arg): Ignore -pass-through=.
	(plugin_maybe_claim): Call cmdline_check_object_only_section
	on claimed IR files.

	* scripttempl/armbpabi.sc: Also discard .gnu_object_only
	sections.
	* scripttempl/elf.sc: Likewise.
	* scripttempl/elf32sh-symbian.sc: Likewise.
	* scripttempl/elf64hppa.sc: Likewise.
	* scripttempl/elfxtensa.sc: Likewise.
	* scripttempl/mep.sc: Likewise.
	* scripttempl/pe.sc: Likewise.
	* scripttempl/pep.sc: Likewise.

ld/testsuite/

2012-06-24  H.J. Lu  <hongjiu.lu@intel.com>

	* lib/ld-lib.exp (check_lto_available): Test the new linker to
	build DSO.

2011-10-21  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/13287
	* ld-plugin/lto.exp (lto_link_tests): Add a test for PR ld/13287.

	* ld-plugin/pr13287.cc: New.

2011-10-07  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/13229
	PR ld/13244
	* ld-plugin/lto.exp (lto_link_elf_tests): Add tests for PRs
	ld/13229 and ld/13244.

	* ld-plugin/pr13229.cc: New.
	* ld-plugin/pr13229.d: Likewise.
	* ld-plugin/pr13244.c: Likewise.
	* ld-plugin/pr13244.d: Likewise.

2011-09-23  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/13201
	* ld-plugin/lto.exp (lto_link_tests): Add a test for PR ld/13201.
	(lto_run_tests): Likewise.

	* ld-plugin/pr13201.c: New.
	* ld-plugin/pr13201.out: Likewise.

2011-09-16  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/12975
	* ld-plugin/lto.exp (lto_link_elf_tests): Add a test for PR
	ld/12975.

	* ld-plugin/pr12975.c: New.
	* ld-plugin/pr12975.d: Likewise.
	* ld-plugin/pr12975.t: Likewise.

2011-09-14  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/13183
	* ld-plugin/lto.exp (lto_link_tests): Add tests for PR ld/13183.
	(lto_link_symbol_tests): Likewise.

	* ld-plugin/pr13183.d: New.
	* ld-plugin/pr13183a.c: Likewise.
	* ld-plugin/pr13183b.c: Likewise.

	* lib/ld-lib.exp (ar_simple_create): Pass -rc to ar.

2011-08-09  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/13066
	* ld-plugin/lto.exp (lto_run_tests): Add a test for PR ld/13066.

	* ld-plugin/pr13066.cc: New.
	* ld-plugin/pr13066.out: Likewise.

2011-07-11  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/12942
	* ld-plugin/lto.exp (lto_link_elf_tests): Add a test for PR
	ld/12982.

	* ld-plugin/pr12982.c: New.
	* ld-plugin/pr12982.d: Likewise.

2011-07-09  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/12942
	* ld-plugin/lto.exp (lto_link_tests): Add tests for PR ld/12942.
	(lto_run_tests): Likewise.
	Add "PR ld/12942 (3)" test.

	* ld-plugin/pr12942.out: New.
	* ld-plugin/pr12942a.cc: Likewise.
	* ld-plugin/pr12942a.h: Likewise.
	* ld-plugin/pr12942b.cc: Likewise.
	* ld-plugin/pr12942c.cc: Likewise.

2011-06-29  H.J. Lu  <hongjiu.lu@intel.com>

	* ld-plugin/lto.exp (lto_link_elf_tests): Add 2 LTO ELF DSO 
	tests.

	* ld-plugin/lto-17a.c: New.
	* ld-plugin/lto-17a.d: Likewise.
	* ld-plugin/lto-17b-1.d: Likewise.
	* ld-plugin/lto-17b-2.d: Likewise.
	* ld-plugin/lto-17b.c: Likewise.

2011-06-29  H.J. Lu  <hongjiu.lu@intel.com>

	* ld-plugin/lto.exp (lto_link_elf_tests): Add 2 LTO ELF DSO 
	tests.

	* ld-plugin/lto-17a.c: New.
	* ld-plugin/lto-17a.d: Likewise.
	* ld-plugin/lto-17b-1.d: Likewise.
	* ld-plugin/lto-17b-2.d: Likewise.
	* ld-plugin/lto-17b.c: Likewise.

2011-06-29  H.J. Lu  <hongjiu.lu@intel.com>

	* ld-plugin/lto.exp (lto_run_elf_tests): Add "LTO TLS IE".

	* ld-plugin/run-ie.c: New.
	* ld-plugin/run-ie.out: Likewise.

2011-05-14  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/12760
	* ld-plugin/lto.exp (lto_link_tests): Add tests for PR ld/12760.

	* ld-plugin/pr12760a.s: New.
	* ld-plugin/pr12760b.c: Likewise.

2011-05-14  H.J. Lu  <hongjiu.lu@intel.com>

	PR ld/12758
	* ld-plugin/lto.exp (lto_link_tests): Add tests for PR ld/12758.

	* ld-plugin/pr12758a.s: New.
	* ld-plugin/pr12758b.c: Likewise.

2011-05-14  H.J. Lu  <hongjiu.lu@intel.com>

	* ld-plugin/lto.exp (lto_link_symbol_tests): Replace "-e foo"
	with "-Wl,-e,foo".

2011-04-19  H.J. Lu  <hongjiu.lu@intel.com>

	* ld-plugin/dummy.c: New.
	* ld-plugin/dummy.s: Likewise.
	* ld-plugin/func1p.c: Likewise.
	* ld-plugin/func2i.c: Likewise.
	* ld-plugin/func3h.c: Likewise.
	* ld-plugin/lto-10.out: Likewise.
	* ld-plugin/lto-10a.c: Likewise.
	* ld-plugin/lto-10b.c: Likewise.
	* ld-plugin/lto-10r.d: Likewise.
	* ld-plugin/lto-11.out: Likewise.
	* ld-plugin/lto-11a.c: Likewise.
	* ld-plugin/lto-11b.c: Likewise.
	* ld-plugin/lto-11c.c: Likewise.
	* ld-plugin/lto-12.out: Likewise.
	* ld-plugin/lto-12a.c: Likewise.
	* ld-plugin/lto-12b.c: Likewise.
	* ld-plugin/lto-12c.c: Likewise.
	* ld-plugin/lto-13.out: Likewise.
	* ld-plugin/lto-13a.c: Likewise.
	* ld-plugin/lto-13b.c: Likewise.
	* ld-plugin/lto-13c.c: Likewise.
	* ld-plugin/lto-14.out: Likewise.
	* ld-plugin/lto-14a.c: Likewise.
	* ld-plugin/lto-14b.c: Likewise.
	* ld-plugin/lto-14c.c: Likewise.
	* ld-plugin/lto-15.out: Likewise.
	* ld-plugin/lto-15a.c: Likewise.
	* ld-plugin/lto-15b.c: Likewise.
	* ld-plugin/lto-16a.c: Likewise.
	* ld-plugin/lto-16a.d: Likewise.
	* ld-plugin/lto-16b.c: Likewise.
	* ld-plugin/lto-16b.d: Likewise.
	* ld-plugin/lto-1a.c: Likewise.
	* ld-plugin/lto-1b.c: Likewise.
	* ld-plugin/lto-2.c: Likewise.
	* ld-plugin/lto-3.d: Likewise.
	* ld-plugin/lto-3.out: Likewise.
	* ld-plugin/lto-3a.c: Likewise.
	* ld-plugin/lto-3b.c: Likewise.
	* ld-plugin/lto-3c.c: Likewise.
	* ld-plugin/lto-3r.d: Likewise.
	* ld-plugin/lto-4.out: Likewise.
	* ld-plugin/lto-4a.c: Likewise.
	* ld-plugin/lto-4b.c: Likewise.
	* ld-plugin/lto-4c.c: Likewise.
	* ld-plugin/lto-4r-a.d: Likewise.
	* ld-plugin/lto-4r-b.d: Likewise.
	* ld-plugin/lto-4r-c.d: Likewise.
	* ld-plugin/lto-4r-d.d: Likewise.
	* ld-plugin/lto-5.d: Likewise.
	* ld-plugin/lto-5.out: Likewise.
	* ld-plugin/lto-5a.c: Likewise.
	* ld-plugin/lto-5b.c: Likewise.
	* ld-plugin/lto-5r.d: Likewise.
	* ld-plugin/lto-6.c: Likewise.
	* ld-plugin/lto-7.out: Likewise.
	* ld-plugin/lto-7a.c: Likewise.
	* ld-plugin/lto-7b.c: Likewise.
	* ld-plugin/lto-7c.c: Likewise.
	* ld-plugin/lto-7d.c: Likewise.
	* ld-plugin/lto-8.out: Likewise.
	* ld-plugin/lto-8a.c: Likewise.
	* ld-plugin/lto-8b.c: Likewise.
	* ld-plugin/lto-9.cc: Likewise.
	* ld-plugin/lto-9.d: Likewise.
	* ld-plugin/lto.exp: Likewise.
	* ld-plugin/pr12365a.c: Likewise.
	* ld-plugin/pr12365b.c: Likewise.
	* ld-plugin/pr12365c.c: Likewise.
	* ld-plugin/pr12696-1.cc: Likewise.

	* ld-plugin/plugin.exp: Add object files for symbols claimed
	or created by testplugin.

	* lib/ld-lib.exp (check_lto_available): New.

diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 11f3e49..6cd342e 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1029,6 +1029,9 @@ struct bfd_section *bfd_create_gnu_debuglink_section
 bfd_boolean bfd_fill_in_gnu_debuglink_section
    (bfd *abfd, struct bfd_section *sect, const char *filename);
 
+const char *bfd_extract_object_only_section
+   (bfd *abfd);
+
 /* Extracted from libbfd.c.  */
 
 /* Byte swapping macros for user section data.  */
@@ -1554,6 +1557,9 @@ extern asection std_section[4];
 #define BFD_COM_SECTION_NAME "*COM*"
 #define BFD_IND_SECTION_NAME "*IND*"
 
+/* GNU object-only section name.  */
+#define GNU_OBJECT_ONLY_SECTION_NAME ".gnu_object_only"
+
 /* Pointer to the common section.  */
 #define bfd_com_section_ptr (&std_section[0])
 /* Pointer to the undefined section.  */
@@ -5441,6 +5447,14 @@ enum bfd_direction
     both_direction = 3
   };
 
+enum bfd_lto_object_type
+  {
+    lto_non_object,
+    lto_non_ir_object,
+    lto_ir_object,
+    lto_mixed_object
+  };
+
 struct bfd
 {
   /* A unique identifier of the BFD  */
@@ -5588,6 +5602,9 @@ struct bfd
   /* The last section on the section list.  */
   struct bfd_section *section_last;
 
+  /* The object-only section on the section list.  */
+  struct bfd_section *object_only_section;
+
   /* The number of sections.  */
   unsigned int section_count;
 
@@ -5706,6 +5723,9 @@ struct bfd
   /* Set if only required symbols should be added in the link hash table for
      this object.  Used by VMS linkers.  */
   unsigned int selective_search : 1;
+
+  /* LTO object type.  */
+  unsigned int lto_type : 2;
 };
 
 typedef enum bfd_error
@@ -5922,6 +5942,8 @@ void bfd_emul_set_commonpagesize (const char *, bfd_vma);
 
 char *bfd_demangle (bfd *, const char *, int);
 
+asymbol *bfd_group_signature (asection *group, asymbol **isympp);
+
 /* Extracted from archive.c.  */
 symindex bfd_get_next_mapent
    (bfd *abfd, symindex previous, carsym **sym);
diff --git a/bfd/bfd.c b/bfd/bfd.c
index 640b420..9cdac38 100644
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -43,6 +43,14 @@ CODE_FRAGMENT
 .    both_direction = 3
 .  };
 .
+.enum bfd_lto_object_type
+.  {
+.    lto_non_object,
+.    lto_non_ir_object,
+.    lto_ir_object,
+.    lto_mixed_object
+.  };
+.
 .struct bfd
 .{
 .  {* A unique identifier of the BFD  *}
@@ -190,6 +198,9 @@ CODE_FRAGMENT
 .  {* The last section on the section list.  *}
 .  struct bfd_section *section_last;
 .
+.  {* The object-only section on the section list.  *}
+.  struct bfd_section *object_only_section;
+.
 .  {* The number of sections.  *}
 .  unsigned int section_count;
 .
@@ -308,6 +319,9 @@ CODE_FRAGMENT
 .  {* Set if only required symbols should be added in the link hash table for
 .     this object.  Used by VMS linkers.  *}
 .  unsigned int selective_search : 1;
+.
+.  {* LTO object type.  *}
+.  unsigned int lto_type : 2;
 .};
 .
 */
@@ -2021,3 +2035,36 @@ bfd_demangle (bfd *abfd, const char *name, int options)
 
   return res;
 }
+
+/*
+FUNCTION
+	bfd_group_signature
+
+SYNOPSIS
+	asymbol *bfd_group_signature (asection *group, asymbol **isympp);
+
+DESCRIPTION
+	Return a pointer to the symbol used as a signature for GROUP.
+*/
+
+asymbol *
+bfd_group_signature (asection *group, asymbol **isympp)
+{
+  bfd *abfd = group->owner;
+  Elf_Internal_Shdr *ghdr;
+
+  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
+    return NULL;
+
+  ghdr = &elf_section_data (group)->this_hdr;
+  if (ghdr->sh_link < elf_numsections (abfd))
+    {
+      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+      Elf_Internal_Shdr *symhdr = elf_elfsections (abfd) [ghdr->sh_link];
+
+      if (symhdr->sh_type == SHT_SYMTAB
+	  && ghdr->sh_info < symhdr->sh_size / bed->s->sizeof_sym)
+	return isympp[ghdr->sh_info - 1];
+    }
+  return NULL;
+}
diff --git a/bfd/elf.c b/bfd/elf.c
index 48e5d68..d89d6d3 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -2104,6 +2104,7 @@ static const struct bfd_elf_special_section special_sections_g[] =
   { STRING_COMMA_LEN (".gnu.linkonce.b"), -2, SHT_NOBITS,      SHF_ALLOC + SHF_WRITE },
   { STRING_COMMA_LEN (".gnu.lto_"),       -1, SHT_PROGBITS,    SHF_EXCLUDE },
   { STRING_COMMA_LEN (".got"),             0, SHT_PROGBITS,    SHF_ALLOC + SHF_WRITE },
+  { STRING_COMMA_LEN (".gnu_object_only"), 0, SHT_GNU_OBJECT_ONLY, SHF_EXCLUDE },
   { STRING_COMMA_LEN (".gnu.version"),     0, SHT_GNU_versym,  0 },
   { STRING_COMMA_LEN (".gnu.version_d"),   0, SHT_GNU_verdef,  0 },
   { STRING_COMMA_LEN (".gnu.version_r"),   0, SHT_GNU_verneed, 0 },
diff --git a/bfd/elflink.c b/bfd/elflink.c
index 574b6e2..3a1c586 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -2469,6 +2469,18 @@ _bfd_elf_fix_symbol_flags (struct elf_link_hash_entry *h,
     }
   else
     {
+      /* If a plugin symbol is referenced from a non-IR file, mark
+	 the symbol as undefined.  */         
+      if (h->root.non_ir_ref
+	  && (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak)
+	  && h->root.u.def.section->owner != NULL
+	  && (h->root.u.def.section->owner->flags & BFD_PLUGIN) != 0)
+	{
+	  h->root.type = bfd_link_hash_undefined;
+	  h->root.u.undef.abfd = h->root.u.def.section->owner;
+	}
+
       /* Unfortunately, NON_ELF is only correct if the symbol
 	 was first seen in a non-ELF file.  Fortunately, if the symbol
 	 was first seen in an ELF file, we're probably OK unless the
@@ -5131,6 +5143,9 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
 	     something wrong with the archive.  */
 	  if (element->archive_pass != 0)
 	    {
+	      /* Don't load the IR archive member twice.  */
+	      if (element->lto_type == lto_ir_object)
+		continue;
 	      bfd_set_error (bfd_error_bad_value);
 	      goto error_return;
 	    }
diff --git a/bfd/format.c b/bfd/format.c
index 66b9051..181ac05 100644
--- a/bfd/format.c
+++ b/bfd/format.c
@@ -95,6 +95,33 @@ bfd_check_format (bfd *abfd, bfd_format format)
   return bfd_check_format_matches (abfd, format, NULL);
 }
 
+/* Set lto_type in ABFD.  */
+
+static void
+bfd_set_lto_type (bfd *abfd)
+{
+  if (abfd->format == bfd_object
+      && abfd->lto_type == lto_non_object
+      && (abfd->flags & (DYNAMIC | EXEC_P)) == 0)
+    {
+      asection *sec;
+      enum bfd_lto_object_type type = lto_non_ir_object;
+      for (sec = abfd->sections; sec != NULL; sec = sec->next)
+	{
+	  if (strcmp (sec->name, GNU_OBJECT_ONLY_SECTION_NAME) == 0)
+	    {
+	      type = lto_mixed_object;
+	      abfd->object_only_section = sec;
+	      break;
+	    }
+	  else if (type != lto_ir_object
+		   && strncmp (sec->name, ".gnu.lto_", 9) == 0)
+	    type = lto_ir_object;
+	}
+      abfd->lto_type = type;
+    }
+}
+
 /*
 FUNCTION
 	bfd_check_format_matches
@@ -136,7 +163,10 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
     }
 
   if (abfd->format != bfd_unknown)
-    return abfd->format == format;
+    {
+      bfd_set_lto_type (abfd);
+      return abfd->format == format;
+    }
 
   /* Since the target type was defaulted, check them
      all in the hope that one will be uniquely recognized.  */
@@ -322,6 +352,9 @@ bfd_check_format_matches (bfd *abfd, bfd_format format, char ***matching)
 
       if (matching_vector)
 	free (matching_vector);
+
+      bfd_set_lto_type (abfd);
+
       return TRUE;			/* File position has moved, BTW.  */
     }
 
diff --git a/bfd/opncls.c b/bfd/opncls.c
index 7c1d2f9..75d498b 100644
--- a/bfd/opncls.c
+++ b/bfd/opncls.c
@@ -1543,3 +1543,69 @@ bfd_fill_in_gnu_debuglink_section (bfd *abfd,
 
   return TRUE;
 }
+
+/*
+FUNCTION
+	bfd_extract_object_only_section
+
+SYNOPSIS
+	const char *bfd_extract_object_only_section
+	  (bfd *abfd);
+
+DESCRIPTION
+
+	Takes a @var{ABFD} and extract the .gnu_object_only section into
+	a temporary file.
+
+RETURNS
+	The name of the temporary file is returned if all is ok.
+	Otherwise <<NULL>> is returned and bfd_error is set.
+*/
+
+const char *
+bfd_extract_object_only_section (bfd *abfd)
+{
+  asection *sec = abfd->object_only_section;
+  const char *name;
+  FILE *file;
+  bfd_byte *memhunk = NULL;
+  size_t off, size;
+  bfd_error_type err;
+
+  /* Get a temporary object-only file.  */
+  name = make_temp_file (".obj-only.o");
+
+  /* Open the object-only file.  */
+  file = real_fopen (name, FOPEN_WB);
+  if (!bfd_get_full_section_contents (abfd, sec, &memhunk))
+    {
+      err = bfd_get_error ();
+
+loser:
+      free (memhunk);
+      fclose (file);
+      unlink (name);
+      bfd_set_error (err);
+      return NULL;
+    }
+
+  off = 0;
+  size = sec->size;
+  while (off != size)
+    {
+      size_t written, nwrite = size - off;
+
+      written = fwrite (memhunk + off, 1, nwrite, file);
+      if (written < nwrite && ferror (file))
+	{
+	  err = bfd_error_system_call;
+	  goto loser;
+	}
+
+      off += written;
+    }
+
+  free (memhunk);
+  fclose (file);
+  return name;
+}
diff --git a/bfd/plugin.c b/bfd/plugin.c
index 8d2c4b2..1e6d82b 100644
--- a/bfd/plugin.c
+++ b/bfd/plugin.c
@@ -130,6 +130,139 @@ register_claim_file (ld_plugin_claim_file_handler handler)
   return LDPS_OK;
 }
 
+static asection bfd_plugin_fake_text_section
+  = BFD_FAKE_SECTION (bfd_plugin_fake_text_section, 0, 0, ".text", 0);
+static asection bfd_plugin_fake_common_section
+  = BFD_FAKE_SECTION (bfd_plugin_fake_common_section, SEC_IS_COMMON, 0,
+		      NULL, 0);
+
+/* Get symbols from object only section.  */
+
+static void
+bfd_plugin_get_symbols_in_object_only (bfd *abfd)
+{
+  struct plugin_data_struct *plugin_data = abfd->tdata.plugin_data;
+  const char *object_only_file;
+  bfd *nbfd;
+  long storage;
+  long object_only_nsyms, added_nsyms, i;
+  asymbol **object_only_syms, **added_syms;
+
+  plugin_data->object_only_syms = NULL;
+  plugin_data->object_only_nsyms = 0;
+
+  if (abfd->sections == NULL && abfd->my_archive == NULL)
+    {
+      nbfd = bfd_openr (abfd->filename, NULL);
+      if (nbfd == NULL || !bfd_check_format (nbfd, bfd_object))
+	{
+	  (*_bfd_error_handler)
+	    (_("%s: failed to open to extract object only section: %s"),
+	     abfd->filename, bfd_errmsg (bfd_get_error ()));
+	  bfd_close (nbfd);
+	  return;
+	}
+    }
+  else
+    {
+      if (!bfd_check_format (abfd, bfd_object))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: invalid file to extract object only section: %s"),
+	     abfd, bfd_errmsg (bfd_get_error ()));
+	  return;
+	}
+      nbfd = abfd;
+    }
+
+  if (nbfd->lto_type == lto_mixed_object
+      && (nbfd->flags & HAS_SYMS) != 0)
+    {
+      object_only_file = bfd_extract_object_only_section (nbfd);
+      if (object_only_file == NULL)
+	(*_bfd_error_handler)
+	  (_("%B: failed to extract object only section: %s"),
+	   abfd, bfd_errmsg (bfd_get_error ()));
+    }
+  else
+    object_only_file = NULL;
+
+  /* Close the new bfd we just opened.  */
+  if (nbfd != abfd)
+    bfd_close (nbfd);
+
+  /* Return if there is no object only section or there is no
+     symbol in object only section.  */
+  if (!object_only_file)
+    return;
+
+  /* Open the file containing object only section.  */
+  nbfd = bfd_openr (object_only_file, NULL);
+  if (!bfd_check_format (nbfd, bfd_object))
+    {
+      (*_bfd_error_handler)
+	(_("%B: failed to open object only section: %s"),
+	 abfd, bfd_errmsg (bfd_get_error ()));
+      goto quit;
+    }
+
+  storage = bfd_get_symtab_upper_bound (nbfd);
+  if (storage <= 0)
+    {
+      if (storage < 0)
+	(*_bfd_error_handler)
+	  (_("%B: failed to get symbol table in object only section: %s"),
+	   abfd, bfd_errmsg (bfd_get_error ()));
+
+      goto quit;
+    }
+
+  object_only_syms = (asymbol **) bfd_malloc (storage);
+  object_only_nsyms = bfd_canonicalize_symtab (nbfd, object_only_syms);
+
+  /* FIXME: We waste some spaces if not all symbols are copied.  */
+  added_syms = (asymbol **) bfd_alloc (abfd, storage);
+  added_nsyms = 0;
+
+  /* Copy only global symbols from object only section.  */
+  for (i = 0; i < object_only_nsyms; i++)
+    {
+      asection *sec = object_only_syms[i]->section;
+      flagword flags = object_only_syms[i]->flags;
+      asymbol *s;
+
+      if (bfd_is_com_section (sec))
+	sec = &bfd_plugin_fake_common_section;
+      else if (bfd_is_und_section (sec))
+	;
+      else if ((flags & (BSF_GLOBAL | BSF_WEAK | BSF_GNU_UNIQUE)) != 0)
+	sec = &bfd_plugin_fake_text_section;
+      else
+	continue;
+
+      s = bfd_alloc (abfd, sizeof (asymbol)); 
+      BFD_ASSERT (s);
+      added_syms[added_nsyms++] = s;
+
+      s->section = sec;
+      s->the_bfd = abfd;
+      s->name = xstrdup (object_only_syms[i]->name);
+      s->value = 0;
+      s->flags = flags;
+      s->udata.p = NULL;
+    }
+
+  plugin_data->object_only_syms = added_syms;
+  plugin_data->object_only_nsyms = added_nsyms;
+
+  free (object_only_syms);
+
+quit:
+  /* Close and remove the object only section file.  */
+  bfd_close (nbfd);
+  unlink (object_only_file);
+}
+
 static enum ld_plugin_status
 add_symbols (void * handle,
 	     int nsyms,
@@ -142,10 +275,13 @@ add_symbols (void * handle,
   plugin_data->nsyms = nsyms;
   plugin_data->syms = syms;
 
-  if (nsyms != 0)
+  abfd->tdata.plugin_data = plugin_data;
+
+  bfd_plugin_get_symbols_in_object_only (abfd);
+
+  if ((nsyms + plugin_data->object_only_nsyms) != 0)
     abfd->flags |= HAS_SYMS;
 
-  abfd->tdata.plugin_data = plugin_data;
   return LDPS_OK;
 }
 
@@ -389,7 +525,8 @@ static long
 bfd_plugin_get_symtab_upper_bound (bfd *abfd)
 {
   struct plugin_data_struct *plugin_data = abfd->tdata.plugin_data;
-  long nsyms = plugin_data->nsyms;
+  /* Add symbols from object only section.  */
+  long nsyms = plugin_data->nsyms + plugin_data->object_only_nsyms;
 
   BFD_ASSERT (nsyms >= 0);
 
@@ -423,12 +560,7 @@ bfd_plugin_canonicalize_symtab (bfd *abfd,
   struct plugin_data_struct *plugin_data = abfd->tdata.plugin_data;
   long nsyms = plugin_data->nsyms;
   const struct ld_plugin_symbol *syms = plugin_data->syms;
-  static asection fake_section;
-  static asection fake_common_section;
-  int i;
-
-  fake_section.name = ".text";
-  fake_common_section.flags = SEC_IS_COMMON;
+  int i, j;
 
   for (i = 0; i < nsyms; i++)
     {
@@ -441,10 +573,11 @@ bfd_plugin_canonicalize_symtab (bfd *abfd,
       s->name = syms[i].name;
       s->value = 0;
       s->flags = convert_flags (&syms[i]);
+      s->udata.p = NULL;
       switch (syms[i].def)
 	{
 	case LDPK_COMMON:
-	  s->section = &fake_common_section;
+	  s->section = &bfd_plugin_fake_common_section;
 	  break;
 	case LDPK_UNDEF:
 	case LDPK_WEAKUNDEF:
@@ -452,15 +585,18 @@ bfd_plugin_canonicalize_symtab (bfd *abfd,
 	  break;
 	case LDPK_DEF:
 	case LDPK_WEAKDEF:
-	  s->section = &fake_section;
+	  s->section = &bfd_plugin_fake_text_section;
 	  break;
 	default:
 	  BFD_ASSERT (0);
 	}
-
-      s->udata.p = (void *) &syms[i];
     }
 
+  /* Copy symbols from object only section.  */
+  nsyms += plugin_data->object_only_nsyms;
+  for (j = 0; j < plugin_data->object_only_nsyms; j++, i++)
+    alocation[i] = plugin_data->object_only_syms[j];
+
   return nsyms;
 }
 
diff --git a/bfd/plugin.h b/bfd/plugin.h
index 3091f97..2db087f 100644
--- a/bfd/plugin.h
+++ b/bfd/plugin.h
@@ -30,6 +30,8 @@ typedef struct plugin_data_struct
 {
   int nsyms;
   const struct ld_plugin_symbol *syms;
+  int object_only_nsyms;
+  asymbol **object_only_syms;
 }
 plugin_data_struct;
 
diff --git a/bfd/section.c b/bfd/section.c
index a3b7c56..f24e2da 100644
--- a/bfd/section.c
+++ b/bfd/section.c
@@ -552,6 +552,9 @@ CODE_FRAGMENT
 .#define BFD_COM_SECTION_NAME "*COM*"
 .#define BFD_IND_SECTION_NAME "*IND*"
 .
+.{* GNU object-only section name.  *}
+.#define GNU_OBJECT_ONLY_SECTION_NAME ".gnu_object_only"
+.
 .{* Pointer to the common section.  *}
 .#define bfd_com_section_ptr (&std_section[0])
 .{* Pointer to the undefined section.  *}
diff --git a/binutils/objcopy.c b/binutils/objcopy.c
index 40250ad..d0d112f 100644
--- a/binutils/objcopy.c
+++ b/binutils/objcopy.c
@@ -918,30 +918,6 @@ is_specified_symbol (const char *name, htab_t htab)
   return htab_find (htab, name) != NULL;
 }
 
-/* Return a pointer to the symbol used as a signature for GROUP.  */
-
-static asymbol *
-group_signature (asection *group)
-{
-  bfd *abfd = group->owner;
-  Elf_Internal_Shdr *ghdr;
-
-  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
-    return NULL;
-
-  ghdr = &elf_section_data (group)->this_hdr;
-  if (ghdr->sh_link < elf_numsections (abfd))
-    {
-      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
-      Elf_Internal_Shdr *symhdr = elf_elfsections (abfd) [ghdr->sh_link];
-
-      if (symhdr->sh_type == SHT_SYMTAB
-	  && ghdr->sh_info < symhdr->sh_size / bed->s->sizeof_sym)
-	return isympp[ghdr->sh_info - 1];
-    }
-  return NULL;
-}
-
 /* Return TRUE if the section is a DWO section.  */
 
 static bfd_boolean
@@ -1009,7 +985,7 @@ is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
       /* PR binutils/3181
 	 If we are going to strip the group signature symbol, then
 	 strip the group section too.  */
-      gsym = group_signature (sec);
+      gsym = bfd_group_signature (sec, isympp);
       if (gsym != NULL)
 	gname = gsym->name;
       else
@@ -2608,7 +2584,7 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
 
   if ((isection->flags & SEC_GROUP) != 0)
     {
-      asymbol *gsym = group_signature (isection);
+      asymbol *gsym = bfd_group_signature (isection, isympp);
 
       if (gsym != NULL)
 	{
diff --git a/binutils/readelf.c b/binutils/readelf.c
index 2fcd582..f41d71f 100644
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -3052,6 +3052,7 @@ get_section_type_name (unsigned int sh_type)
     case 0x7ffffffd:		return "AUXILIARY";
     case 0x7fffffff:		return "FILTER";
     case SHT_GNU_LIBLIST:	return "GNU_LIBLIST";
+    case SHT_GNU_OBJECT_ONLY:	return "GNU_OBJECT_ONLY";
 
     default:
       if ((sh_type >= SHT_LOPROC) && (sh_type <= SHT_HIPROC))
diff --git a/gas/testsuite/gas/elf/section9.d b/gas/testsuite/gas/elf/section9.d
index 1acf63e..bb66fa5 100644
--- a/gas/testsuite/gas/elf/section9.d
+++ b/gas/testsuite/gas/elf/section9.d
@@ -4,4 +4,5 @@
 #...
 [ 	]*\[.*\][ 	]+\.gnu\.lto_main[ 	]+PROGBITS.*[ 	]+E[   ]+.*
 [ 	]*\[.*\][ 	]+\.gnu\.lto_\.pureconst[ 	]+PROGBITS.*[ 	]+E[   ]+.*
+[ 	]*\[.*\][ 	]+\.gnu_object_only[ 	]+GNU_OBJECT_ONLY.*[ 	]+E[   ]+.*
 #pass
diff --git a/gas/testsuite/gas/elf/section9.s b/gas/testsuite/gas/elf/section9.s
index 6b8b107..abcdea1 100644
--- a/gas/testsuite/gas/elf/section9.s
+++ b/gas/testsuite/gas/elf/section9.s
@@ -2,3 +2,5 @@
 	.byte 0,0,0,0
 	.section .gnu.lto_.pureconst,"",%progbits
 	.byte 0,0,0,0
+	.section .gnu_object_only
+	.byte 0,0,0,0
diff --git a/include/bfdlink.h b/include/bfdlink.h
index d900b47..d0b5606 100644
--- a/include/bfdlink.h
+++ b/include/bfdlink.h
@@ -380,6 +380,12 @@ struct bfd_link_info
   /* TRUE if ok to have multiple definition.  */
   unsigned int allow_multiple_definition: 1;
 
+  /* TRUE if .gnu_object_only section should be created.  */
+  unsigned int emit_gnu_object_only: 1;
+
+  /* TRUE if .gnu_object_only section is being created.  */
+  unsigned int emitting_gnu_object_only: 1;
+
   /* TRUE if ok to have version with no definition.  */
   unsigned int allow_undefined_version: 1;
 
diff --git a/include/elf/common.h b/include/elf/common.h
index 58e489a..5622c5e 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -472,6 +472,7 @@
 #define SHT_GNU_ATTRIBUTES 0x6ffffff5	/* Object attributes */
 #define SHT_GNU_HASH	0x6ffffff6	/* GNU style symbol hash table */
 #define SHT_GNU_LIBLIST	0x6ffffff7	/* List of prelink dependencies */
+#define SHT_GNU_OBJECT_ONLY 0x6ffffff8	/* Object only */
 
 /* The next three section types are defined by Solaris, and are named
    SHT_SUNW*.  We use them in GNU code, so we also define SHT_GNU*
diff --git a/ld/emultempl/alphaelf.em b/ld/emultempl/alphaelf.em
index 21064ad..ec0965a 100644
--- a/ld/emultempl/alphaelf.em
+++ b/ld/emultempl/alphaelf.em
@@ -100,7 +100,7 @@ alpha_finish (void)
   if (limit_32bit)
     elf_elfheader (link_info.output_bfd)->e_flags |= EF_ALPHA_32BIT;
 
-  finish_default ();
+  gld${EMULATION_NAME}_finish ();
 }
 EOF
 
diff --git a/ld/emultempl/armelf.em b/ld/emultempl/armelf.em
index 3b881dd..a37a35d 100644
--- a/ld/emultempl/armelf.em
+++ b/ld/emultempl/armelf.em
@@ -365,7 +365,7 @@ gld${EMULATION_NAME}_after_allocation (void)
 }
 
 static void
-gld${EMULATION_NAME}_finish (void)
+arm_finish (void)
 {
   struct bfd_link_hash_entry * h;
 
@@ -388,7 +388,7 @@ gld${EMULATION_NAME}_finish (void)
 	}
     }
 
-  finish_default ();
+  gld${EMULATION_NAME}_finish ();
 
   if (thumb_entry_symbol)
     {
@@ -689,4 +689,4 @@ LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=arm_elf_create_output_section_statements
 LDEMUL_BEFORE_PARSE=gld"${EMULATION_NAME}"_before_parse
 
 # Call the extra arm-elf function
-LDEMUL_FINISH=gld${EMULATION_NAME}_finish
+LDEMUL_FINISH=arm_finish
diff --git a/ld/emultempl/elf32.em b/ld/emultempl/elf32.em
index de51050..218ebb2 100644
--- a/ld/emultempl/elf32.em
+++ b/ld/emultempl/elf32.em
@@ -68,6 +68,7 @@ static void gld${EMULATION_NAME}_before_allocation (void);
 static void gld${EMULATION_NAME}_after_allocation (void);
 static lang_output_section_statement_type *gld${EMULATION_NAME}_place_orphan
   (asection *, const char *, int);
+static void gld${EMULATION_NAME}_finish (void);
 EOF
 
 if [ "x${USE_LIBPATH}" = xyes ] ; then
@@ -1759,6 +1760,8 @@ output_rel_find (asection *sec, int isdyn)
   return last;
 }
 
+static int orphan_init_done = 0;
+
 /* Place an orphan section.  We use this to put random SHF_ALLOC
    sections in the right segment.  */
 
@@ -1767,7 +1770,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
 				   const char *secname,
 				   int constraint)
 {
-  static struct orphan_save hold[] =
+  static struct orphan_save orig_hold[] =
     {
       { ".text",
 	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,
@@ -1794,6 +1797,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
 	SEC_HAS_CONTENTS,
 	0, 0, 0, 0 },
     };
+  static struct orphan_save hold[ARRAY_SIZE (orig_hold)];
   enum orphan_save_index
     {
       orphan_text = 0,
@@ -1805,7 +1809,6 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
       orphan_sdata,
       orphan_nonalloc
     };
-  static int orphan_init_done = 0;
   struct orphan_save *place;
   lang_output_section_statement_type *after;
   lang_output_section_statement_type *os;
@@ -1882,15 +1885,22 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
 
   if (!orphan_init_done)
     {
-      struct orphan_save *ho;
+      struct orphan_save *ho, *horig;
 
       for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)
+      for (ho = hold, horig = orig_hold;
+	   ho < hold + ARRAY_SIZE (hold);
+	   ++ho, ++horig)
+	{
+	  *ho = *horig;
+	  if (ho->name != NULL)
 	if (ho->name != NULL)
 	  {
 	    ho->os = lang_output_section_find (ho->name);
 	    if (ho->os != NULL && ho->os->flags == 0)
 	      ho->os->flags = ho->flags;
 	  }
+	}
       orphan_init_done = 1;
     }
 
@@ -1960,6 +1970,27 @@ gld${EMULATION_NAME}_place_orphan (asection *s,
 EOF
 fi
 
+fragment <<EOF
+
+/* Final emulation specific call.  */
+
+static void
+gld${EMULATION_NAME}_finish (void)
+{
+EOF
+if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
+fragment <<EOF
+  /* Support the object-only output.  */
+  if (link_info.emit_gnu_object_only)
+    orphan_init_done = 0;
+
+EOF
+fi
+fragment <<EOF
+  finish_default ();
+}
+EOF
+
 if test x"$LDEMUL_AFTER_ALLOCATION" != xgld"$EMULATION_NAME"_after_allocation; then
 fragment <<EOF
 
@@ -2492,7 +2523,7 @@ struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
   ${LDEMUL_GET_SCRIPT-gld${EMULATION_NAME}_get_script},
   "${EMULATION_NAME}",
   "${OUTPUT_FORMAT}",
-  ${LDEMUL_FINISH-finish_default},
+  ${LDEMUL_FINISH-gld${EMULATION_NAME}_finish},
   ${LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS-NULL},
   ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-gld${EMULATION_NAME}_open_dynamic_archive},
   ${LDEMUL_PLACE_ORPHAN-gld${EMULATION_NAME}_place_orphan},
diff --git a/ld/emultempl/ppc64elf.em b/ld/emultempl/ppc64elf.em
index d578f7f..bad3e2c 100644
--- a/ld/emultempl/ppc64elf.em
+++ b/ld/emultempl/ppc64elf.em
@@ -533,7 +533,7 @@ gld${EMULATION_NAME}_after_allocation (void)
 /* Final emulation specific call.  */
 
 static void
-gld${EMULATION_NAME}_finish (void)
+ppc_finish (void)
 {
   /* e_entry on PowerPC64 points to the function descriptor for
      _start.  If _start is missing, default to the first function
@@ -565,7 +565,7 @@ gld${EMULATION_NAME}_finish (void)
     }
 
   ppc64_elf_restore_symbols (&link_info);
-  finish_default ();
+  gld${EMULATION_NAME}_finish ();
 }
 
 
@@ -867,6 +867,6 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'
 #
 LDEMUL_BEFORE_ALLOCATION=ppc_before_allocation
 LDEMUL_AFTER_ALLOCATION=gld${EMULATION_NAME}_after_allocation
-LDEMUL_FINISH=gld${EMULATION_NAME}_finish
+LDEMUL_FINISH=ppc_finish
 LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=ppc_create_output_section_statements
 LDEMUL_NEW_VERS_PATTERN=gld${EMULATION_NAME}_new_vers_pattern
diff --git a/ld/emultempl/spuelf.em b/ld/emultempl/spuelf.em
index eef57aa..d5387a9 100644
--- a/ld/emultempl/spuelf.em
+++ b/ld/emultempl/spuelf.em
@@ -416,7 +416,7 @@ spu_elf_relink (void)
 /* Final emulation specific call.  */
 
 static void
-gld${EMULATION_NAME}_finish (void)
+spu_finish (void)
 {
   if (is_spu_target ())
     {
@@ -432,7 +432,7 @@ gld${EMULATION_NAME}_finish (void)
 	einfo ("%P: --auto-overlay ignored with zero local store range\n");
     }
 
-  finish_default ();
+  gld${EMULATION_NAME}_finish ();
 }
 
 static char *
@@ -832,5 +832,5 @@ PARSE_AND_LIST_ARGS_CASES='
 
 LDEMUL_AFTER_OPEN=spu_after_open
 LDEMUL_BEFORE_ALLOCATION=spu_before_allocation
-LDEMUL_FINISH=gld${EMULATION_NAME}_finish
+LDEMUL_FINISH=spu_finish
 LDEMUL_CHOOSE_TARGET=gld${EMULATION_NAME}_choose_target
diff --git a/ld/ldfile.c b/ld/ldfile.c
index e9091e9..2362f11 100644
--- a/ld/ldfile.c
+++ b/ld/ldfile.c
@@ -319,7 +319,9 @@ success:
 	  plugin_maybe_claim (&file, entry);
 	}
     }
+  else
 #endif /* ENABLE_PLUGINS */
+    cmdline_check_object_only_section (entry->the_bfd, FALSE);
 
   /* It opened OK, the format checked out, and the plugins have had
      their chance to claim it, so this is success.  */
diff --git a/ld/ldlang.c b/ld/ldlang.c
index 5a4eef7..c362d4b 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -38,6 +38,7 @@
 #include "ldctor.h"
 #include "ldfile.h"
 #include "ldemul.h"
+#include "ldwrite.h"
 #include "fnmatch.h"
 #include "demangle.h"
 #include "hashtab.h"
@@ -46,6 +47,9 @@
 #include "plugin.h"
 #endif /* ENABLE_PLUGINS */
 
+/* FIXME: Put it here to avoid NAME conflict from ldgram.h.  */
+#include "elf-bfd.h"
+
 #ifndef offsetof
 #define offsetof(TYPE, MEMBER) ((size_t) & (((TYPE*) 0)->MEMBER))
 #endif
@@ -69,6 +73,9 @@ static struct bfd_hash_table lang_definedness_table;
 static lang_statement_list_type *stat_save[10];
 static lang_statement_list_type **stat_save_ptr = &stat_save[0];
 static struct unique_sections *unique_section_list;
+static cmdline_list_type cmdline_object_only_file_list;
+static cmdline_list_type cmdline_object_only_archive_list;
+static cmdline_list_type cmdline_temp_object_only_list;
 
 /* Forward declarations.  */
 static void exp_init_os (etree_type *);
@@ -89,6 +96,10 @@ static void lang_record_phdrs (void);
 static void lang_do_version_exports_section (void);
 static void lang_finalize_version_expr_head
   (struct bfd_elf_version_expr_head *);
+static void cmdline_lists_init (void);
+static void cmdline_get_object_only_input_files (void);
+static void print_cmdline_list (cmdline_union_type *);
+static bfd_boolean cmdline_on_object_only_archive_list_p (bfd *);
 
 /* Exported variables.  */
 const char *output_target;
@@ -1204,14 +1215,17 @@ output_section_statement_table_free (void)
 /* Build enough state so that the parser can build its tree.  */
 
 void
-lang_init (void)
+lang_init (bfd_boolean object_only)
 {
-  obstack_begin (&stat_obstack, 1000);
+  if (!object_only)
+    obstack_begin (&stat_obstack, 1000);
 
   stat_ptr = &statement_list;
 
   output_section_statement_table_init ();
 
+  cmdline_lists_init ();
+
   lang_list_init (stat_ptr);
 
   lang_list_init (&input_file_chain);
@@ -1230,10 +1244,11 @@ lang_init (void)
      simpler to re-use working machinery than using a linked list in terms
      of code-complexity here in ld, besides the initialization which just
      looks like other code here.  */
-  if (!bfd_hash_table_init_n (&lang_definedness_table,
-			      lang_definedness_newfunc,
-			      sizeof (struct lang_definedness_hash_entry),
-			      3))
+  if (!object_only
+      && !bfd_hash_table_init_n (&lang_definedness_table,
+				 lang_definedness_newfunc,
+				 sizeof (struct lang_definedness_hash_entry),
+				 3))
     einfo (_("%P%F: can not create hash table: %E\n"));
 }
 
@@ -2767,6 +2782,12 @@ load_symbols (lang_input_statement_type *entry,
 		  loaded = FALSE;
 		}
 
+	      if (link_info.emitting_gnu_object_only)
+		{
+		  if (!cmdline_on_object_only_archive_list_p (member))
+		    continue;
+		}
+
 	      subsbfd = member;
 	      if (!(*link_info.callbacks
 		    ->add_archive_element) (&link_info, member,
@@ -6691,7 +6712,38 @@ lang_process (void)
 	  open_input_bfds (statement_list.head, OPEN_BFD_RESCAN);
 	}
     }
+  else
 #endif /* ENABLE_PLUGINS */
+    if (link_info.relocatable)
+    {
+      /* Check if .gnu_object_only section should be created.  */
+      bfd *p;
+      int object_type;
+
+      object_type = 0;
+      for (p = link_info.input_bfds; p != (bfd *) NULL; p = p->link_next)
+	{
+	  object_type |= 1 << p->lto_type;
+	  if ((object_type & (1 << lto_mixed_object)) != 0
+	      || ((object_type
+		   & (1 << lto_non_ir_object
+		      | 1 << lto_ir_object))
+		  == (1 << lto_non_ir_object | 1 << lto_ir_object)))
+	    {
+	      link_info.emit_gnu_object_only = TRUE;
+	      break;
+	    }
+	}
+
+      if (verbose
+	  && (cmdline_object_only_file_list.head
+	      || cmdline_object_only_archive_list.head))
+	{
+	  info_msg (_("Object-only input files:\n "));
+	  print_cmdline_list (cmdline_object_only_file_list.head);
+	  print_cmdline_list (cmdline_object_only_archive_list.head);
+	}
+    }
 
   link_info.gc_sym_list = &entry_symbol;
   if (entry_symbol.name == NULL)
@@ -8091,3 +8143,961 @@ lang_ld_feature (char *str)
       p = q;
     }
 }
+
+static void
+cmdline_lists_init (void)
+{
+  cmdline_object_only_file_list.tail
+    = &cmdline_object_only_file_list.head;
+  cmdline_object_only_archive_list.tail
+    = &cmdline_object_only_archive_list.head;
+  cmdline_temp_object_only_list.tail
+    = &cmdline_temp_object_only_list.head;
+}
+
+/* Allocate an item with TYPE and DATA.  */
+
+static cmdline_union_type *
+cmdline_list_new (cmdline_enum_type type, void *data)
+{
+  cmdline_union_type *new_opt;
+
+  new_opt = (cmdline_union_type *) stat_alloc (sizeof (*new_opt));
+  new_opt->header.type = type;
+  switch (type)
+    {
+    default:
+      break;
+    case cmdline_is_file_enum:
+      new_opt->file.filename = (const char *) data;
+      break;
+    case cmdline_is_bfd_enum:
+      new_opt->abfd.abfd = (bfd *) data;
+      break;
+    }
+  return new_opt;
+}
+
+/* Append an item with TYPE and DATA to LIST.  */
+
+static void
+cmdline_list_append (cmdline_list_type *list, cmdline_enum_type type,
+		     void *data)
+{
+  cmdline_union_type *new_opt = cmdline_list_new (type, data);
+  new_opt->header.next = NULL;
+  *list->tail = new_opt;
+  list->tail = &new_opt->header.next;
+}
+
+static void
+print_cmdline_list (cmdline_union_type *c)
+{
+  for (; c != NULL; c = c->header.next)
+    switch (c->header.type)
+      {
+      default:
+	abort ();
+      case cmdline_is_file_enum:
+	info_msg (" %s", c->file.filename);
+	break;
+      case cmdline_is_bfd_enum:
+	info_msg (" [%B]", c->abfd.abfd);
+	break;
+      }
+
+  info_msg ("\n");
+}
+
+/* Return TRUE if ABFD is on cmdline_object_only_archive_list.  */
+
+static bfd_boolean
+cmdline_on_object_only_archive_list_p (bfd *abfd)
+{
+  cmdline_union_type *c, *next;
+  bfd *archive, *obfd, *oarchive;
+  ufile_ptr origin = abfd->origin;
+
+  archive = bfd_my_archive (abfd);
+  for (c = cmdline_object_only_archive_list.head; c != NULL; c = next)
+    {
+      if (c->header.type != cmdline_is_bfd_enum)
+	abort ();
+
+      next = c->header.next;
+      obfd = c->abfd.abfd;
+      oarchive = bfd_my_archive (obfd);
+
+      /* The list is grouped by archive file name and sorted by member
+	 origin.  */
+      if (strcmp (archive->filename, oarchive->filename) != 0)
+	continue;
+
+      if (origin == obfd->origin)
+	return TRUE;
+      else if (origin < obfd->origin)
+	return FALSE;
+    }
+
+  return FALSE;
+}
+
+/* Append an item with TYPE and DATA to cmdline_object_only_file_list
+   or cmdline_object_only_archive_list if needed.  */
+
+static void
+cmdline_object_only_list_append (cmdline_enum_type type, void *data)
+{
+  cmdline_union_type *c;
+  cmdline_union_type *new_opt, *next, **prev;
+  bfd *abfd, *archive;
+  bfd *obfd, *oarchive;
+  bfd *nbfd, *narchive;
+  ufile_ptr origin, norigin;
+
+  /* Put it on cmdline_object_only_file_list if it isn't an archive
+     member.  */
+  switch (type)
+    {
+    default:
+      abort ();
+    case cmdline_is_bfd_enum:
+      abfd = (bfd *) data;
+      archive = bfd_my_archive (abfd);
+      if (archive)
+	break;
+    case cmdline_is_file_enum:
+      cmdline_list_append (&cmdline_object_only_file_list, type, data);
+      return;
+    }
+
+  /* Put archive member on cmdline_object_only_archive_list and sort
+     the list by archive name and archive member origin.  */
+  new_opt = (cmdline_union_type *) stat_alloc (sizeof (*new_opt));
+  new_opt->header.type = cmdline_is_bfd_enum;
+  new_opt->header.next = NULL;
+  new_opt->abfd.abfd = (bfd *) data;
+
+  c = cmdline_object_only_archive_list.head;
+  if (c == NULL)
+    {
+      cmdline_object_only_archive_list.head = new_opt;
+      cmdline_object_only_archive_list.tail = &new_opt->header.next;
+      return;
+    }
+
+  prev = NULL;
+  origin = abfd->origin;
+  for (; c != NULL; c = next)
+    {
+      if (c->header.type != cmdline_is_bfd_enum)
+	abort ();
+
+      next = c->header.next;
+
+      obfd = c->abfd.abfd;
+      oarchive = bfd_my_archive (obfd);
+
+      if (strcmp (archive->filename, oarchive->filename) == 0)
+	{
+	  bfd_boolean after;
+
+	  if (origin < obfd->origin)
+	    {
+	      /* Insert it before the current.  */
+	      new_opt->header.next = c;
+	      if (prev)
+		*prev = new_opt;
+	      else
+		cmdline_object_only_archive_list.head = new_opt;
+	      return;
+	    }
+
+	  after = TRUE;
+
+	  /* Check origin.  */
+	  while (next)
+	    {
+	      if (next->header.type != cmdline_is_bfd_enum)
+		abort ();
+
+	      nbfd = next->abfd.abfd;
+	      norigin = nbfd->origin;
+	      if (origin > norigin)
+		{
+		  /* Insert it after NEXT.  */
+		  break;
+		}
+
+	      narchive = bfd_my_archive (nbfd);
+	      if (strcmp (archive->filename, narchive->filename) != 0)
+		{
+		  /* Insert it befor NEXT.  */
+		  after = FALSE;
+		  break;
+		}
+
+	      c = next;
+	      next = next->header.next;
+	    }
+
+	  if (after && next)
+	    {
+	      c = next;
+	      next = next->header.next;
+	    }
+
+	  if (*cmdline_object_only_archive_list.tail == c->header.next)
+	    cmdline_object_only_archive_list.tail
+	      = &new_opt->header.next;
+
+	  prev = &c->header.next;
+	  new_opt->header.next = next;
+	  *prev = new_opt;
+	  return;
+	}
+
+      prev = &c->header.next;
+    }
+
+  *cmdline_object_only_archive_list.tail = new_opt;
+  cmdline_object_only_archive_list.tail = &new_opt->header.next;
+}
+
+/* Get object-only input files.  */
+
+static void
+cmdline_get_object_only_input_files (void)
+{
+  cmdline_union_type *c, *next;
+  bfd *abfd, *archive;
+  bfd *nbfd, *narchive;
+
+  /* Add files first.  */
+  for (c = cmdline_object_only_file_list.head;
+       c != NULL; c = c->header.next)
+    switch (c->header.type)
+      {
+      default:
+	abort ();
+      case cmdline_is_file_enum:
+	lang_add_input_file (c->file.filename,
+			     lang_input_file_is_file_enum, NULL);
+	break;
+      case cmdline_is_bfd_enum:
+	abfd = c->abfd.abfd;
+	if (bfd_my_archive (abfd))
+	  abort ();
+	lang_add_input_file (abfd->filename,
+			     lang_input_file_is_file_enum, NULL);
+	break;
+      }
+
+  /* Add archive members next.  */
+  for (c = cmdline_object_only_archive_list.head; c != NULL; c = next)
+    {
+      if (c->header.type != cmdline_is_bfd_enum)
+	abort ();
+
+      next = c->header.next;
+
+      abfd = c->abfd.abfd;
+      archive = bfd_my_archive (abfd);
+   
+      /* Add the first archive of the archive member group.  */
+      lang_add_input_file (archive->filename,
+			   lang_input_file_is_file_enum, NULL);
+
+      /* Skip the rest members in the archive member group.  */
+      do
+	{
+	  if (!next)
+	    break;
+
+	  if (next->header.type != cmdline_is_bfd_enum)
+	    abort ();
+
+	  next = next->header.next;
+	  if (!next)
+	    break;
+	  nbfd = next->abfd.abfd;
+	  narchive = bfd_my_archive (nbfd);
+	}
+      while (strcmp (archive->filename, narchive->filename) == 0);
+    }
+}
+
+struct cmdline_arg
+{
+  bfd *obfd;
+  asymbol **isympp;
+  int status;
+};
+
+/* Create a section in OBFD with the same
+   name and attributes as ISECTION in IBFD.  */
+
+static void
+setup_section (bfd *ibfd, sec_ptr isection, void *p)
+{
+  struct cmdline_arg *arg = (struct cmdline_arg *) p;
+  bfd *obfd = arg->obfd;
+  asymbol **isympp = arg->isympp;
+  const char *name = isection->name;
+  sec_ptr osection;
+  const char *err;
+
+  /* Skip the object-only section.  */
+  if (ibfd->object_only_section == isection)
+    return;
+
+  /* If we have already failed earlier on, do not keep on generating
+     complaints now.  */
+  if (arg->status)
+    return;
+
+  osection = bfd_make_section_anyway_with_flags (obfd, name,
+						 isection->flags);
+
+  if (osection == NULL)
+    {
+      err = _("failed to create output section");
+      goto loser;
+    }
+
+  osection->size = isection->size;
+  osection->vma = isection->vma;
+  osection->lma = isection->lma;
+  osection->alignment_power = isection->alignment_power;
+
+  /* Copy merge entity size.  */
+  osection->entsize = isection->entsize;
+
+  /* This used to be mangle_section; we do here to avoid using
+     bfd_get_section_by_name since some formats allow multiple
+     sections with the same name.  */
+  isection->output_section = osection;
+  isection->output_offset = 0;
+
+  if ((isection->flags & SEC_GROUP) != 0)
+    {
+      asymbol *gsym = bfd_group_signature (isection, isympp);
+
+      if (gsym != NULL)
+	{
+	  gsym->flags |= BSF_KEEP;
+	  if (ibfd->xvec->flavour == bfd_target_elf_flavour)
+	    elf_group_id (isection) = gsym;
+	}
+    }
+
+  /* Allow the BFD backend to copy any private data it understands
+     from the input section to the output section.  */
+  if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
+    {
+      err = _("failed to copy private data");
+      goto loser;
+    }
+
+  /* All went well.  */
+  return;
+
+loser:
+  arg->status = 1;
+  einfo (_("%P%F: setup_section: %s: %s\n"), err, name);
+}
+
+/* Copy the data of input section ISECTION of IBFD
+   to an output section with the same name in OBFD.
+   If stripping then don't copy any relocation info.  */
+
+static void
+copy_section (bfd *ibfd, sec_ptr isection, void *p)
+{
+  struct cmdline_arg *arg = (struct cmdline_arg *) p;
+  bfd *obfd = arg->obfd;
+  asymbol **isympp = arg->isympp;
+  arelent **relpp;
+  long relcount;
+  sec_ptr osection;
+  bfd_size_type size;
+  long relsize;
+  flagword flags;
+  const char *err;
+
+  /* Skip the object-only section.  */
+  if (ibfd->object_only_section == isection)
+    return;
+
+  /* If we have already failed earlier on, do not keep on generating
+     complaints now.  */
+  if (arg->status)
+    return;
+
+  flags = bfd_get_section_flags (ibfd, isection);
+  if ((flags & SEC_GROUP) != 0)
+    return;
+
+  osection = isection->output_section;
+  size = bfd_get_section_size (isection);
+
+  if (size == 0 || osection == 0)
+    return;
+
+  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
+
+  if (relsize < 0)
+    {
+      /* Do not complain if the target does not support relocations.  */
+      if (relsize == -1
+	  && bfd_get_error () == bfd_error_invalid_operation)
+	relsize = 0;
+      else
+	{
+	  err = bfd_errmsg (bfd_get_error ());
+	  goto loser;
+	}
+    }
+
+  if (relsize == 0)
+    bfd_set_reloc (obfd, osection, NULL, 0);
+  else
+    {
+      relpp = (arelent **) xmalloc (relsize);
+      relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, isympp);
+      if (relcount < 0)
+	{
+	  err = _("relocation count is negative");
+	  goto loser;
+	}
+
+      bfd_set_reloc (obfd, osection,
+		     relcount == 0 ? NULL : relpp, relcount);
+      if (relcount == 0)
+	free (relpp);
+    }
+
+  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS)
+    {
+      bfd_byte *memhunk = NULL;
+
+      if (!bfd_get_full_section_contents (ibfd, isection, &memhunk))
+	{
+	  err = bfd_errmsg (bfd_get_error ());
+	  goto loser;
+	}
+
+      if (!bfd_set_section_contents (obfd, osection, memhunk, 0, size))
+	{
+	  err = bfd_errmsg (bfd_get_error ());
+	  goto loser;
+	}
+      free (memhunk);
+    }
+
+  /* All went well.  */
+  return;
+
+loser:
+  einfo (_("%P%F: copy_section: %s: %s\n"), err, isection->name);
+}
+/* Open the temporary bfd created in the same directory as PATH.  */
+
+static bfd *
+cmdline_fopen_temp (const char *path, const char *target,
+		    const char *mode)
+{
+#define template "ldXXXXXX"
+  const char *slash = strrchr (path, '/');
+  char *tmpname;
+  size_t len;
+  int fd;
+
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+  {
+    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
+    char *bslash = strrchr (path, '\\');
+
+    if (slash == NULL || (bslash != NULL && bslash > slash))
+      slash = bslash;
+    if (slash == NULL && path[0] != '\0' && path[1] == ':')
+      slash = path + 1;
+  }
+#endif
+
+  if (slash != (char *) NULL)
+    {
+      len = slash - path;
+      tmpname = (char *) xmalloc (len + sizeof (template) + 2);
+      memcpy (tmpname, path, len);
+
+#ifdef HAVE_DOS_BASED_FILE_SYSTEM
+      /* If tmpname is "X:", appending a slash will make it a root
+	 directory on drive X, which is NOT the same as the current
+	 directory on drive X.  */
+      if (len == 2 && tmpname[1] == ':')
+	tmpname[len++] = '.';
+#endif
+      tmpname[len++] = '/';
+    }
+  else
+    {
+      tmpname = (char *) xmalloc (sizeof (template));
+      len = 0;
+    }
+
+  memcpy (tmpname + len, template, sizeof (template));
+#undef template
+
+#ifdef HAVE_MKSTEMP
+  fd = mkstemp (tmpname);
+#else
+  tmpname = mktemp (tmpname);
+  if (tmpname == NULL)
+    return NULL;
+  fd = open (tmpname, O_RDWR | O_CREAT | O_EXCL, 0600);
+#endif
+  if (fd == -1)
+    return NULL;
+  return bfd_fopen (tmpname, target, mode, fd);
+}
+
+/* Add the object-only section.  */
+
+static void
+cmdline_add_object_only_section (bfd_byte *contents, size_t size)
+{
+  bfd_vma start;
+  flagword flags;
+  enum bfd_architecture iarch;
+  unsigned int imach;
+  long symcount;
+  long symsize;
+  asymbol **isympp = NULL;
+  asymbol **osympp = NULL;
+  bfd *obfd = NULL, *ibfd;
+  const char *err;
+  struct arg
+    {
+      bfd *obfd;
+      asymbol **isympp;
+      int status;
+    } arg;
+  char **matching;
+  const char *ofilename = NULL;
+  asection *sec;
+
+  ibfd = bfd_openr (output_filename, output_target);
+  if (!ibfd)
+    {
+      err = bfd_errmsg (bfd_get_error ());
+      goto loser;
+    }
+
+  if (!bfd_check_format_matches (ibfd, bfd_object, &matching))
+    {
+      err = bfd_errmsg (bfd_get_error ());
+      goto loser;
+    }
+
+  obfd = cmdline_fopen_temp (output_filename, output_target, "w");
+  if (!obfd)
+    {
+      err = bfd_errmsg (bfd_get_error ());
+      goto loser;
+    }
+  ofilename = bfd_get_filename (obfd);
+
+  if (!bfd_set_format (obfd, bfd_object))
+    {
+      err = bfd_errmsg (bfd_get_error ());
+      goto loser;
+    }
+
+  /* Copy the start address, flags and architecture of input file to
+     output file.  */
+  flags = bfd_get_file_flags (ibfd);
+  start = bfd_get_start_address (ibfd);
+  iarch = bfd_get_arch (ibfd);
+  imach = bfd_get_mach (ibfd);
+  if (!bfd_set_start_address (obfd, start)
+      || !bfd_set_file_flags (obfd, flags)
+      || !bfd_set_arch_mach (obfd, iarch, imach))
+    {
+      err = bfd_errmsg (bfd_get_error ());
+      goto loser;
+    }
+	
+  symsize = bfd_get_symtab_upper_bound (ibfd);
+  if (symsize < 0)
+    {
+      err = bfd_errmsg (bfd_get_error ());
+      goto loser;
+    }
+
+  isympp = (asymbol **) xmalloc (symsize);
+  symcount = bfd_canonicalize_symtab (ibfd, isympp);
+  if (symcount < 0)
+    {
+      err = bfd_errmsg (bfd_get_error ());
+      goto loser;
+    }
+
+  arg.obfd = obfd;
+  arg.isympp = isympp;
+  arg.status = 0;
+
+  /* BFD mandates that all output sections be created and sizes set before
+     any output is done.  Thus, we traverse all sections multiple times.  */
+  bfd_map_over_sections (ibfd, setup_section, &arg);
+
+  if (arg.status)
+    {
+      err = _("error setting up sections");
+      goto loser;
+    }
+
+  /* Allow the BFD backend to copy any private data it understands
+     from the input section to the output section.  */
+  if (! bfd_copy_private_header_data (ibfd, obfd))
+    {
+      err = _("error copying private header data");
+      goto loser;
+    }
+
+  /* Create the object-only section.  */
+  sec = bfd_make_section_with_flags (obfd,
+				     GNU_OBJECT_ONLY_SECTION_NAME,
+				     (SEC_HAS_CONTENTS
+				      | SEC_READONLY
+				      | SEC_DATA
+				      | SEC_LINKER_CREATED));
+  if (sec == NULL)
+    {
+      err = _("can't create object-only section");
+      goto loser;
+    }
+
+  if (! bfd_set_section_size (obfd, sec, size))
+    {
+      err = _("can't set object-only section size");
+      goto loser;
+    }
+
+  if (ibfd->object_only_section)
+    {
+      /* Filter out the object-only section symbol.  */
+      long src_count = 0, dst_count = 0;
+      asymbol **from, **to;
+
+      osympp = (asymbol **) xmalloc (symcount * sizeof (asymbol *));
+      from = isympp;
+      to = osympp;
+      for (; src_count < symcount; src_count++)
+	{
+	  asymbol *sym = from[src_count];
+	  if (bfd_get_section (sym) != ibfd->object_only_section)
+	    to[dst_count++] = sym;
+	}
+      to[dst_count] = NULL;
+      symcount = dst_count;
+      bfd_set_symtab (obfd, osympp, symcount);
+    }
+  else
+    bfd_set_symtab (obfd, isympp, symcount);
+
+  /* This has to happen after the symbol table has been set.  */
+  bfd_map_over_sections (ibfd, copy_section, &arg);
+
+  if (arg.status)
+    {
+      err = _("error copying sections");
+      goto loser;
+    }
+
+  /* Copy the object-only section to the output.  */
+  if (! bfd_set_section_contents (obfd, sec, contents, 0, size))
+    {
+      err = _("error adding object-only section");
+      goto loser;
+    }
+
+  /* Allow the BFD backend to copy any private data it understands
+     from the input BFD to the output BFD.  This is done last to
+     permit the routine to look at the filtered symbol table, which is
+     important for the ECOFF code at least.  */
+  if (! bfd_copy_private_bfd_data (ibfd, obfd))
+    {
+      err = _("error copying private BFD data");
+      goto loser;
+    }
+
+  if (!bfd_close (obfd))
+    {
+      unlink (ofilename);
+      einfo (_("%P%F: failed to finish output with object-only section\n"));
+    }
+
+  /* Must be freed after bfd_close ().  */
+  free (isympp);
+  if (osympp)
+    free (osympp);
+
+  if (rename (ofilename, output_filename))
+    {
+      unlink (ofilename);
+      einfo (_("%P%F: failed to rename output with object-only section\n"));
+    }
+
+  return;
+
+loser:
+  if (isympp)
+    free (isympp);
+  if (osympp)
+    free (osympp);
+  if (obfd)
+    bfd_close (obfd);
+  if (ofilename)
+    unlink (ofilename);
+  einfo (_("%P%F: failed to add object-only section: %s\n"), err);
+}
+
+/* Emit the final output with object-only section.  */
+
+void
+cmdline_emit_object_only_section (void)
+{
+  const char *saved_output_filename = output_filename;
+  int fd;
+  size_t size, off;
+  bfd_byte *contents;
+  struct stat st;
+
+  /* Get a temporary object-only file.  */
+  output_filename = make_temp_file (".obj-only.o");
+
+  had_output_filename = FALSE;
+  link_info.input_bfds = NULL;
+  link_info.input_bfds_tail = &link_info.input_bfds;
+
+  lang_init (TRUE);
+
+  ld_parse_linker_script ();
+
+  /* Set up the object-only output. */
+  lang_final ();
+
+  /* Open the object-only file for output.  */
+  lang_for_each_statement (ldlang_open_output);
+
+  ldemul_create_output_section_statements ();
+
+  if (!bfd_section_already_linked_table_init ())
+    einfo (_("%P%F: Failed to create hash table\n"));
+
+  /* Call cmdline_on_object_only_archive_list_p to check which member
+     should be loaded.  */
+  input_flags.whole_archive = TRUE;
+
+  /* Set it to avoid adding more to cmdline lists.  */
+  link_info.emitting_gnu_object_only = TRUE;
+
+  /* Get object-only input files.  */
+  cmdline_get_object_only_input_files ();
+
+  /* Open object-only input files.  */
+  open_input_bfds (statement_list.head, FALSE);
+
+  ldemul_after_open ();
+
+  bfd_section_already_linked_table_free ();
+
+  /* Make sure that we're not mixing architectures.  We call this
+     after all the input files have been opened, but before we do any
+     other processing, so that any operations merge_private_bfd_data
+     does on the output file will be known during the rest of the
+     link.  */
+  lang_check ();
+
+  /* Size up the common data.  */
+  lang_common ();
+
+  /* Update wild statements.  */
+  update_wild_statements (statement_list.head);
+
+  /* Run through the contours of the script and attach input sections
+     to the correct output sections.  */
+  map_input_to_output_sections (statement_list.head, NULL, NULL);
+
+  /* Find any sections not attached explicitly and handle them.  */
+  lang_place_orphans ();
+
+  /* Do anything special before sizing sections.  This is where ELF
+     and other back-ends size dynamic sections.  */
+  ldemul_before_allocation ();
+
+  /* Size up the sections.  */
+  lang_size_sections (NULL, ! RELAXATION_ENABLED);
+
+  /* See if anything special should be done now we know how big
+     everything is.  This is where relaxation is done.  */
+  ldemul_after_allocation ();
+
+  ldemul_finish ();
+
+  /* Make sure that the section addresses make sense.  */
+  if (command_line.check_section_addresses)
+    lang_check_section_addresses ();
+
+  lang_end ();
+  
+  ldwrite ();
+
+  lang_finish ();
+
+  if (! bfd_close (link_info.output_bfd))
+    einfo (_("%P%F:%s: final close failed on object-only output: %E\n"),
+	   output_filename);
+
+  /* Read in the object-only file.  */
+  fd = open (output_filename, O_RDONLY | O_BINARY);
+  if (fd < 0)
+    {
+      bfd_set_error (bfd_error_system_call);
+      einfo (_("%P%F:%s: cannot open object-only output: %E"),
+	     output_filename);
+    }
+
+  /* Get the object-only file size.  */
+  if (fstat (fd, &st) != 0)
+    {
+      bfd_set_error (bfd_error_system_call);
+      einfo (_("%P%F:%s: cannot stat object-only output: %E"),
+	     output_filename);
+    }
+
+  size = st.st_size;
+  off = 0;
+  contents = (bfd_byte *) xmalloc (size);
+  while (off != size)
+    {
+      ssize_t got;
+
+      got = read (fd, contents + off, size - off);
+      if (got < 0)
+	{
+	  bfd_set_error (bfd_error_system_call);
+	  einfo (_("%P%F:%s: read failed on object-only output: %E"),
+		 output_filename);
+	}
+
+      off += got;
+    }
+
+  close (fd);
+
+  /* Remove the temporary object-only file.  */ 
+  unlink (output_filename);
+
+  output_filename = saved_output_filename;
+
+  cmdline_add_object_only_section (contents, size);
+
+  free (contents);
+}
+
+/* Extract the object-only section.  */
+
+static const char *
+cmdline_extract_object_only_section (bfd *abfd)
+{
+  const char *name = bfd_extract_object_only_section (abfd);
+
+  if (name == NULL)
+    einfo (_("%P%F: cannot extract object-only section from %B: %E"),
+	   abfd);
+
+  /* It should be removed after it is done.  */
+  cmdline_list_append (&cmdline_temp_object_only_list,
+		       cmdline_is_file_enum, (void *) name);
+
+  return name;
+}
+
+/* Check and handle the object-only section.   */
+
+void
+cmdline_check_object_only_section (bfd *abfd, bfd_boolean lto)
+{
+  const char *filename;
+
+  if (link_info.emitting_gnu_object_only
+      || abfd->format != bfd_object)
+    return;
+
+  if (lto)
+    {
+      /* For LTO link, we only need to extract object-only section
+	 from the mixed object, add it to input, and put it on LTO
+	 claimed output.  */
+      switch (abfd->lto_type)
+	{
+	default:
+	  abort ();
+	case lto_mixed_object:
+	  filename = cmdline_extract_object_only_section (abfd);
+	  lang_add_input_file (filename,
+			       lang_input_file_is_file_enum, NULL);
+	  break;
+	case lto_non_ir_object:
+	case lto_ir_object:
+	  break;
+	}
+    }
+  else if (link_info.relocatable)
+    {
+      /* For non-LTO relocatable link, we need to append non-IR object
+	 file and the object file in object-only section to the object
+	 only list.  */
+      switch (abfd->lto_type)
+	{
+	default:
+	  abort ();
+	case lto_mixed_object:
+	  filename = cmdline_extract_object_only_section (abfd);
+	  cmdline_object_only_list_append (cmdline_is_file_enum,
+					  (void *) filename);
+	  break;
+	case lto_non_ir_object:
+	  cmdline_object_only_list_append (cmdline_is_bfd_enum, abfd);
+	  break;
+	case lto_ir_object:
+	  break;
+	}
+    }
+}
+
+/* Remove temporary object-only files.  */
+
+void
+cmdline_remove_object_only_files (void)
+{
+  cmdline_union_type *c;
+
+#ifdef ENABLE_PLUGINS
+  if (plugin_save_temps)
+    return;
+#endif
+
+  c = cmdline_temp_object_only_list.head;
+  for (; c != NULL; c = c->header.next)
+    switch (c->header.type)
+      {
+      default:
+	abort ();
+      case cmdline_is_file_enum:
+	unlink (c->file.filename);
+	break;
+      }
+}
diff --git a/ld/ldlang.h b/ld/ldlang.h
index d5ea8d2..89c11d3 100644
--- a/ld/ldlang.h
+++ b/ld/ldlang.h
@@ -488,7 +488,7 @@ extern lang_statement_list_type input_file_chain;
 extern int lang_statement_iteration;
 
 extern void lang_init
-  (void);
+  (bfd_boolean);
 extern void lang_finish
   (void);
 extern lang_memory_region_type * lang_memory_region_lookup
@@ -664,4 +664,45 @@ ldlang_override_segment_assignment
 extern void
 lang_ld_feature (char *);
 
+typedef enum
+{
+  cmdline_is_file_enum,
+  cmdline_is_bfd_enum
+} cmdline_enum_type;
+
+typedef struct cmdline_header_struct
+{
+  union cmdline_union *next;
+  cmdline_enum_type type;
+} cmdline_header_type;
+
+typedef struct cmdline_file_struct
+{
+  cmdline_header_type header;
+  const char *filename;
+} cmdline_file_type;
+
+typedef struct cmdline_bfd_struct
+{
+  cmdline_header_type header;
+  bfd *abfd;
+} cmdline_bfd_type;
+
+typedef union cmdline_union
+{
+  cmdline_header_type header;
+  cmdline_file_type file;
+  cmdline_bfd_type abfd;
+} cmdline_union_type;
+
+typedef struct cmdline_list
+{
+  cmdline_union_type *head;
+  cmdline_union_type **tail;
+} cmdline_list_type;
+
+extern void cmdline_emit_object_only_section (void);
+extern void cmdline_check_object_only_section (bfd *, bfd_boolean);
+extern void cmdline_remove_object_only_files (void);
+
 #endif
diff --git a/ld/ldlex.h b/ld/ldlex.h
index 5e3d2fc..e14107c 100644
--- a/ld/ldlex.h
+++ b/ld/ldlex.h
@@ -132,6 +132,7 @@ enum option_values
 #ifdef ENABLE_PLUGINS
   OPTION_PLUGIN,
   OPTION_PLUGIN_OPT,
+  OPTION_PLUGIN_SAVE_TEMPS,
 #endif /* ENABLE_PLUGINS */
   OPTION_DEFAULT_SCRIPT,
   OPTION_PRINT_OUTPUT_FORMAT,
diff --git a/ld/ldmain.c b/ld/ldmain.c
index 15f8ebf..7338ac7 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -219,6 +219,9 @@ main (int argc, char **argv)
 
   xatexit (ld_cleanup);
 
+  /* Remove temporary object-only files.  */
+  xatexit (cmdline_remove_object_only_files);
+
   /* Set up the sysroot directory.  */
   ld_sysroot = get_sysroot (argc, argv);
   if (*ld_sysroot)
@@ -295,7 +298,7 @@ main (int argc, char **argv)
   default_target = ldemul_choose_target (argc, argv);
   config.maxpagesize = bfd_emul_get_maxpagesize (default_target);
   config.commonpagesize = bfd_emul_get_commonpagesize (default_target);
-  lang_init ();
+  lang_init (FALSE);
   ldemul_before_parse ();
   lang_has_input_file = FALSE;
   parse_args (argc, argv);
@@ -311,34 +314,7 @@ main (int argc, char **argv)
 
   ldemul_set_symbols ();
 
-  /* If we have not already opened and parsed a linker script,
-     try the default script from command line first.  */
-  if (saved_script_handle == NULL
-      && command_line.default_script != NULL)
-    {
-      ldfile_open_command_file (command_line.default_script);
-      parser_input = input_script;
-      yyparse ();
-    }
-
-  /* If we have not already opened and parsed a linker script
-     read the emulation's appropriate default script.  */
-  if (saved_script_handle == NULL)
-    {
-      int isfile;
-      char *s = ldemul_get_script (&isfile);
-
-      if (isfile)
-	ldfile_open_default_command_file (s);
-      else
-	{
-	  lex_string = s;
-	  lex_redirect (s, _("built in linker script"), 1);
-	}
-      parser_input = input_script;
-      yyparse ();
-      lex_string = NULL;
-    }
+  ld_parse_linker_script ();
 
   if (verbose)
     {
@@ -445,6 +421,8 @@ main (int argc, char **argv)
       if (! bfd_close (link_info.output_bfd))
 	einfo (_("%F%B: final close failed: %E\n"), link_info.output_bfd);
 
+      link_info.output_bfd = NULL;
+
       /* If the --force-exe-suffix is enabled, and we're making an
 	 executable file and it doesn't end in .exe, copy it to one
 	 which does.  */
@@ -491,6 +469,9 @@ main (int argc, char **argv)
 	}
     }
 
+  if (link_info.emit_gnu_object_only)
+    cmdline_emit_object_only_section ();
+
   END_PROGRESS (program_name);
 
   if (config.stats)
@@ -780,7 +761,9 @@ add_archive_element (struct bfd_link_info *info,
 	    }
 	}
     }
+  else
 #endif /* ENABLE_PLUGINS */
+    cmdline_check_object_only_section (input->the_bfd, FALSE);
 
   ldlang_add_file (input);
 
@@ -1153,7 +1136,7 @@ warning_callback (struct bfd_link_info *info ATTRIBUTE_UNUSED,
     einfo ("%P: %s%s\n", _("warning: "), warning);
   else if (symbol == NULL)
     einfo ("%B: %s%s\n", abfd, _("warning: "), warning);
-  else
+  else if ((abfd->flags & BFD_PLUGIN) == 0)
     {
       struct warning_callback_info cinfo;
 
@@ -1460,3 +1443,38 @@ notice (struct bfd_link_info *info,
 
   return TRUE;
 }
+
+/* Parse the linker script.   */
+
+void
+ld_parse_linker_script ()
+{
+  /* If we have not already opened and parsed a linker script,
+     try the default script from command line first.  */
+  if (saved_script_handle == NULL
+      && command_line.default_script != NULL)
+    {
+      ldfile_open_command_file (command_line.default_script);
+      parser_input = input_script;
+      yyparse ();
+    }
+
+  /* If we have not already opened and parsed a linker script
+     read the emulation's appropriate default script.  */
+  if (saved_script_handle == NULL)
+    {
+      int isfile;
+      char *s = ldemul_get_script (&isfile);
+
+      if (isfile)
+	ldfile_open_default_command_file (s);
+      else
+	{
+	  lex_string = s;
+	  lex_redirect (s, _("built in linker script"), 1);
+	}
+      parser_input = input_script;
+      yyparse ();
+      lex_string = NULL;
+    }
+}
diff --git a/ld/ldmain.h b/ld/ldmain.h
index 8363833..4e5cd55 100644
--- a/ld/ldmain.h
+++ b/ld/ldmain.h
@@ -43,4 +43,6 @@ extern void add_ysym (const char *);
 extern void add_wrap (const char *);
 extern void add_keepsyms_file (const char *);
 
+extern void ld_parse_linker_script (void);
+
 #endif
diff --git a/ld/lexsup.c b/ld/lexsup.c
index fc410c9..bdb3a53 100644
--- a/ld/lexsup.c
+++ b/ld/lexsup.c
@@ -168,6 +168,9 @@ static const struct ld_option ld_options[] =
     '\0', N_("PLUGIN"), N_("Load named plugin"), ONE_DASH },
   { {"plugin-opt", required_argument, NULL, OPTION_PLUGIN_OPT},
     '\0', N_("ARG"), N_("Send arg to last-loaded plugin"), ONE_DASH },
+  { {"plugin-save-temps", no_argument, NULL, OPTION_PLUGIN_SAVE_TEMPS},
+    '\0', NULL, N_("Store plugin intermediate files permanently"),
+    ONE_DASH },
   { {"flto", optional_argument, NULL, OPTION_IGNORE},
     '\0', NULL, N_("Ignored for GCC LTO option compatibility"),
     ONE_DASH },
@@ -958,6 +961,9 @@ parse_args (unsigned argc, char **argv)
 	  if (plugin_opt_plugin_arg (optarg))
 	    einfo(_("%P%F: bad -plugin-opt option\n"));
 	  break;
+	case OPTION_PLUGIN_SAVE_TEMPS:
+	  plugin_save_temps = TRUE;
+	  break;
 #endif /* ENABLE_PLUGINS */
 	case 'q':
 	  link_info.emitrelocations = TRUE;
diff --git a/ld/plugin.c b/ld/plugin.c
index 7e3d2a3..3e28013 100644
--- a/ld/plugin.c
+++ b/ld/plugin.c
@@ -39,6 +39,9 @@
 /* Report plugin symbols.  */
 bfd_boolean report_plugin_symbols;
 
+/* Store plugin intermediate files permanently.  */
+bfd_boolean plugin_save_temps;
+
 /* The suffix to append to the name of the real (claimed) object file
    when generating a dummy BFD to hold the IR symbols sent from the
    plugin.  For cosmetic use only; appears in maps, crefs etc.  */
@@ -210,6 +213,17 @@ plugin_opt_plugin_arg (const char *arg)
   if (!last_plugin)
     return set_plugin_error (_("<no plugin>"));
 
+  /* Ignore -pass-through= from GCC driver.  */
+  if (*arg == '-')
+    {
+      const char *p;
+      for (p = arg + 1; p; p++)
+	if (*p != '-')
+	  break;
+      if (strncmp (p, "pass-through=", 13) == 0)
+	return 0;
+    }
+
   newarg = xmalloc (sizeof *newarg);
   newarg->arg = arg;
   newarg->next = NULL;
@@ -868,6 +882,9 @@ plugin_maybe_claim (struct ld_plugin_input_file *file,
   close (file->fd);
   if (claimed)
     {
+      /* Check object only section.  */
+      cmdline_check_object_only_section (entry->the_bfd, TRUE);
+
       /* Discard the real file's BFD and substitute the dummy one.  */
 
       /* BFD archive handling caches elements so we can't call
@@ -921,13 +938,16 @@ plugin_call_cleanup (void)
     {
       if (curplug->cleanup_handler && !curplug->cleanup_done)
 	{
-	  enum ld_plugin_status rv;
-	  curplug->cleanup_done = TRUE;
-	  called_plugin = curplug;
-	  rv = (*curplug->cleanup_handler) ();
-	  called_plugin = NULL;
-	  if (rv != LDPS_OK)
-	    set_plugin_error (curplug->name);
+	  if (!plugin_save_temps)
+	    {
+	      enum ld_plugin_status rv;
+	      curplug->cleanup_done = TRUE;
+	      called_plugin = curplug;
+	      rv = (*curplug->cleanup_handler) ();
+	      called_plugin = NULL;
+	      if (rv != LDPS_OK)
+		set_plugin_error (curplug->name);
+	    }
 	  dlclose (curplug->dlhandle);
 	}
       curplug = curplug->next;
diff --git a/ld/plugin.h b/ld/plugin.h
index dc32295..e3e6ee3 100644
--- a/ld/plugin.h
+++ b/ld/plugin.h
@@ -24,6 +24,9 @@
 /* Report plugin symbols.  */
 extern bfd_boolean report_plugin_symbols;
 
+/* Store plugin intermediate files permanently.  */
+extern bfd_boolean plugin_save_temps;
+
 /* Set at all symbols read time, to avoid recursively offering the plugin
    its own newly-added input files and libs to claim.  */
 extern bfd_boolean no_more_claiming;
diff --git a/ld/scripttempl/armbpabi.sc b/ld/scripttempl/armbpabi.sc
index 575d47c..2f3d6ec 100644
--- a/ld/scripttempl/armbpabi.sc
+++ b/ld/scripttempl/armbpabi.sc
@@ -30,7 +30,7 @@ INTERP=".interp       0 : { *(.interp) }"
 PLT=".plt          ${RELOCATING-0} : { *(.plt) }"
 RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
 DATARELRO=".data.rel.ro : { *(.data.rel.ro.local) *(.data.rel.ro .data.rel.ro.*) }"
-DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink)  *(.gnu.lto_*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.gnu_object_only) }"
 if test -z "${NO_SMALL_DATA}"; then
   SBSS=".sbss         ${RELOCATING-0} :
   {
diff --git a/ld/scripttempl/elf.sc b/ld/scripttempl/elf.sc
index 17c2cf1..56ea806 100644
--- a/ld/scripttempl/elf.sc
+++ b/ld/scripttempl/elf.sc
@@ -158,7 +158,7 @@ RELA_IPLT=".rela.iplt    ${RELOCATING-0} :
 DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
 RODATA=".${RODATA_NAME}       ${RELOCATING-0} : { *(.${RODATA_NAME}${RELOCATING+ .${RODATA_NAME}.* .gnu.linkonce.r.*}) }"
 DATARELRO=".data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }"
-DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.gnu_object_only) }"
 if test -z "${NO_SMALL_DATA}"; then
   SBSS=".${SBSS_NAME}         ${RELOCATING-0} :
   {
diff --git a/ld/scripttempl/elf32sh-symbian.sc b/ld/scripttempl/elf32sh-symbian.sc
index e612185..c0305d3 100644
--- a/ld/scripttempl/elf32sh-symbian.sc
+++ b/ld/scripttempl/elf32sh-symbian.sc
@@ -83,7 +83,7 @@ fi
     PLT=".plt            : { *(.plt) } :dynamic :dyn"
 DYNAMIC=".dynamic        : { *(.dynamic) } :dynamic :dyn"
  RODATA=".rodata    ALIGN(4) : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
-DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.directive)  *(.gnu.lto_*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.directive)  *(.gnu.lto_*) *(.gnu_object_only) }"
 test -z "$GOT" && GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.got) } :dynamic :dyn"
 INIT_ARRAY=".init_array   ${RELOCATING-0} :
   {
diff --git a/ld/scripttempl/elf64hppa.sc b/ld/scripttempl/elf64hppa.sc
index 18090e6..46e8bb4 100644
--- a/ld/scripttempl/elf64hppa.sc
+++ b/ld/scripttempl/elf64hppa.sc
@@ -127,7 +127,7 @@ fi
 DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
 RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
 DATARELRO=".data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }"
-DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink)  *(.gnu.lto_*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.gnu_object_only) }"
 if test -z "${NO_SMALL_DATA}"; then
   SBSS=".sbss         ${RELOCATING-0} :
   {
diff --git a/ld/scripttempl/elfxtensa.sc b/ld/scripttempl/elfxtensa.sc
index d330230..0ba1402 100644
--- a/ld/scripttempl/elfxtensa.sc
+++ b/ld/scripttempl/elfxtensa.sc
@@ -140,7 +140,7 @@ fi
 DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
 RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
 DATARELRO=".data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) }"
-DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink)  *(.gnu.lto_*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.gnu_object_only) }"
 INIT_LIT=".init.literal 0 : { *(.init.literal)	}"
 INIT=".init         0 : { *(.init)		}"
 FINI_LIT=".fini.literal 0 : { *(.fini.literal)	}"
diff --git a/ld/scripttempl/mep.sc b/ld/scripttempl/mep.sc
index 3fc1352..fa8ddb4 100644
--- a/ld/scripttempl/mep.sc
+++ b/ld/scripttempl/mep.sc
@@ -114,7 +114,7 @@ fi
 DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
 RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
 DATARELRO=".data.rel.ro : { *(.data.rel.ro.local) *(.data.rel.ro .data.rel.ro.*) }"
-DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink)  *(.gnu.lto_*) }"
+DISCARDED="/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.gnu_object_only) }"
 if test -z "${NO_SMALL_DATA}"; then
   SBSS=".sbss         ${RELOCATING-0} :
   {
diff --git a/ld/scripttempl/pe.sc b/ld/scripttempl/pe.sc
index 3a27952..b44fe8b 100644
--- a/ld/scripttempl/pe.sc
+++ b/ld/scripttempl/pe.sc
@@ -148,6 +148,7 @@ SECTIONS
     *(.drectve)
     ${RELOCATING+ *(.note.GNU-stack)}
     ${RELOCATING+ *(.gnu.lto_*)}
+    ${RELOCATING+ *(.gnu_object_only)}
   }
 
   .idata ${RELOCATING+BLOCK(__section_alignment__)} :
diff --git a/ld/scripttempl/pep.sc b/ld/scripttempl/pep.sc
index b2113fe..fcc3c83 100644
--- a/ld/scripttempl/pep.sc
+++ b/ld/scripttempl/pep.sc
@@ -154,6 +154,7 @@ SECTIONS
     *(.drectve)
     ${RELOCATING+ *(.note.GNU-stack)}
     ${RELOCATING+ *(.gnu.lto_*)}
+    ${RELOCATING+ *(.gnu_object_only)}
   }
 
   .idata ${RELOCATING+BLOCK(__section_alignment__)} :
diff --git a/ld/testsuite/ld-plugin/dummy.c b/ld/testsuite/ld-plugin/dummy.c
new file mode 100644
index 0000000..5c03287
--- /dev/null
+++ b/ld/testsuite/ld-plugin/dummy.c
@@ -0,0 +1 @@
+/* An empty file.  */
diff --git a/ld/testsuite/ld-plugin/dummy.s b/ld/testsuite/ld-plugin/dummy.s
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/ld/testsuite/ld-plugin/dummy.s
@@ -0,0 +1 @@
+
diff --git a/ld/testsuite/ld-plugin/func1p.c b/ld/testsuite/ld-plugin/func1p.c
new file mode 100644
index 0000000..917dcbb
--- /dev/null
+++ b/ld/testsuite/ld-plugin/func1p.c
@@ -0,0 +1,8 @@
+extern int retval;
+
+int
+__attribute__ ((visibility ("protected")))
+func1 (void)
+{
+  return retval;
+}
diff --git a/ld/testsuite/ld-plugin/func2i.c b/ld/testsuite/ld-plugin/func2i.c
new file mode 100644
index 0000000..00d7cdd
--- /dev/null
+++ b/ld/testsuite/ld-plugin/func2i.c
@@ -0,0 +1,8 @@
+extern int retval;
+
+int
+__attribute__ ((visibility ("internal")))
+func2 (void)
+{
+  return retval;
+}
diff --git a/ld/testsuite/ld-plugin/func3h.c b/ld/testsuite/ld-plugin/func3h.c
new file mode 100644
index 0000000..525de63
--- /dev/null
+++ b/ld/testsuite/ld-plugin/func3h.c
@@ -0,0 +1,8 @@
+extern int retval;
+
+int
+__attribute__ ((visibility ("hidden")))
+func3 (void)
+{
+  return retval;
+}
diff --git a/ld/testsuite/ld-plugin/lto-10.out b/ld/testsuite/ld-plugin/lto-10.out
new file mode 100644
index 0000000..ce01362
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-10.out
@@ -0,0 +1 @@
+hello
diff --git a/ld/testsuite/ld-plugin/lto-10a.c b/ld/testsuite/ld-plugin/lto-10a.c
new file mode 100644
index 0000000..93d57b5
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-10a.c
@@ -0,0 +1,6 @@
+extern int foo(void);
+
+int main(void)
+{
+  return foo();
+}
diff --git a/ld/testsuite/ld-plugin/lto-10b.c b/ld/testsuite/ld-plugin/lto-10b.c
new file mode 100644
index 0000000..507055b
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-10b.c
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+int foo(void)
+{
+  printf ("hello\n");
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-10r.d b/ld/testsuite/ld-plugin/lto-10r.d
new file mode 100644
index 0000000..689e6ec
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-10r.d
@@ -0,0 +1,7 @@
+#ld: -r tmpdir/lto-10a.o tmpdir/lto-10b.o
+#source: dummy.s
+#nm: -p
+
+#...
+[0-9a-f]+ C __gnu_lto_v.*
+#pass
diff --git a/ld/testsuite/ld-plugin/lto-11.out b/ld/testsuite/ld-plugin/lto-11.out
new file mode 100644
index 0000000..899682a
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-11.out
@@ -0,0 +1,2 @@
+Hello from foo!
+Hello from bar!
diff --git a/ld/testsuite/ld-plugin/lto-11a.c b/ld/testsuite/ld-plugin/lto-11a.c
new file mode 100644
index 0000000..5193972
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-11a.c
@@ -0,0 +1,9 @@
+extern void foo(void);
+extern void bar(void);
+
+int main(void)
+{
+  foo();
+  bar();
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-11b.c b/ld/testsuite/ld-plugin/lto-11b.c
new file mode 100644
index 0000000..62d61ec
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-11b.c
@@ -0,0 +1,6 @@
+extern int printf(const char *, ...);
+
+void foo(void)
+{
+  printf("Hello from %s!\n", __FUNCTION__);
+}
diff --git a/ld/testsuite/ld-plugin/lto-11c.c b/ld/testsuite/ld-plugin/lto-11c.c
new file mode 100644
index 0000000..8cd40b9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-11c.c
@@ -0,0 +1,6 @@
+extern int printf(const char *, ...);
+
+void bar(void)
+{
+  printf("Hello from %s!\n", __FUNCTION__);
+}
diff --git a/ld/testsuite/ld-plugin/lto-12.out b/ld/testsuite/ld-plugin/lto-12.out
new file mode 100644
index 0000000..d86bac9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-12.out
@@ -0,0 +1 @@
+OK
diff --git a/ld/testsuite/ld-plugin/lto-12a.c b/ld/testsuite/ld-plugin/lto-12a.c
new file mode 100644
index 0000000..30ff3d9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-12a.c
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include <stdlib.h>
+
+extern int value;
+
+int
+main (int argc, char **argv)
+{
+  int n = 10 * (argc + 1);
+  char *p = malloc (n);
+  __builtin_memcpy (p, argv[0], n);
+  if (value != -1)
+    abort ();
+  printf ("OK\n");
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-12b.c b/ld/testsuite/ld-plugin/lto-12b.c
new file mode 100644
index 0000000..c2b00e4
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-12b.c
@@ -0,0 +1 @@
+int value = -1;
diff --git a/ld/testsuite/ld-plugin/lto-12c.c b/ld/testsuite/ld-plugin/lto-12c.c
new file mode 100644
index 0000000..ecd1bd4
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-12c.c
@@ -0,0 +1,15 @@
+#include <string.h>
+
+extern int value;
+
+void *memcpy(void *dest, const void *src, size_t n)
+{
+  char *d = (char *) dest;
+  const char *s = (const char *) src;
+
+  while (n--)
+    *d++ = *s++;
+
+  value = 1;
+  return dest;
+}
diff --git a/ld/testsuite/ld-plugin/lto-13.out b/ld/testsuite/ld-plugin/lto-13.out
new file mode 100644
index 0000000..3bd1f0e
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-13.out
@@ -0,0 +1,2 @@
+foo
+bar
diff --git a/ld/testsuite/ld-plugin/lto-13a.c b/ld/testsuite/ld-plugin/lto-13a.c
new file mode 100644
index 0000000..5193972
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-13a.c
@@ -0,0 +1,9 @@
+extern void foo(void);
+extern void bar(void);
+
+int main(void)
+{
+  foo();
+  bar();
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-13b.c b/ld/testsuite/ld-plugin/lto-13b.c
new file mode 100644
index 0000000..7c87a5e
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-13b.c
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+void
+bar (void)
+{
+  printf ("bar\n");
+}
diff --git a/ld/testsuite/ld-plugin/lto-13c.c b/ld/testsuite/ld-plugin/lto-13c.c
new file mode 100644
index 0000000..4859019
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-13c.c
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+void
+foo (void)
+{
+  printf ("foo\n");
+}
diff --git a/ld/testsuite/ld-plugin/lto-14.out b/ld/testsuite/ld-plugin/lto-14.out
new file mode 100644
index 0000000..7ef22e9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-14.out
@@ -0,0 +1 @@
+PASS
diff --git a/ld/testsuite/ld-plugin/lto-14a.c b/ld/testsuite/ld-plugin/lto-14a.c
new file mode 100644
index 0000000..d61437b
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-14a.c
@@ -0,0 +1,12 @@
+#include <stdio.h>
+
+extern void foo(void);
+extern int i;
+
+int main()
+{
+  foo();
+  if (i == 0x1234)
+    printf ("PASS\n");
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-14b.c b/ld/testsuite/ld-plugin/lto-14b.c
new file mode 100644
index 0000000..5d3eb75
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-14b.c
@@ -0,0 +1,7 @@
+extern int bar(void);
+extern int i;
+
+void foo(void)
+{
+  i = bar();
+}
diff --git a/ld/testsuite/ld-plugin/lto-14c.c b/ld/testsuite/ld-plugin/lto-14c.c
new file mode 100644
index 0000000..a01e0f9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-14c.c
@@ -0,0 +1,6 @@
+int i;
+
+int bar(void)
+{
+  return 0x1234;
+}
diff --git a/ld/testsuite/ld-plugin/lto-15.out b/ld/testsuite/ld-plugin/lto-15.out
new file mode 100644
index 0000000..7ef22e9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-15.out
@@ -0,0 +1 @@
+PASS
diff --git a/ld/testsuite/ld-plugin/lto-15a.c b/ld/testsuite/ld-plugin/lto-15a.c
new file mode 100644
index 0000000..c4ce5e9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-15a.c
@@ -0,0 +1,7 @@
+#include <stdio.h>
+
+int main(int argc, char **argv)
+{
+  printf ("PASS\n");
+  return (int) ((unsigned long long) argc / argv[0][0]);
+}
diff --git a/ld/testsuite/ld-plugin/lto-15b.c b/ld/testsuite/ld-plugin/lto-15b.c
new file mode 100644
index 0000000..0ae748d
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-15b.c
@@ -0,0 +1,7 @@
+extern void abort (void);
+unsigned long long
+__udivdi3(unsigned long long n, unsigned long long d)
+{
+  abort ();
+  return n + d;
+}
diff --git a/ld/testsuite/ld-plugin/lto-16a.c b/ld/testsuite/ld-plugin/lto-16a.c
new file mode 100644
index 0000000..aa1cbe2
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-16a.c
@@ -0,0 +1 @@
+void foo (void) { }
diff --git a/ld/testsuite/ld-plugin/lto-16a.d b/ld/testsuite/ld-plugin/lto-16a.d
new file mode 100644
index 0000000..76ff1f6
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-16a.d
@@ -0,0 +1,3 @@
+#...
+[0-9a-f]+ T foo
+#...
diff --git a/ld/testsuite/ld-plugin/lto-16b.c b/ld/testsuite/ld-plugin/lto-16b.c
new file mode 100644
index 0000000..31781e8
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-16b.c
@@ -0,0 +1,4 @@
+void
+bar ()
+{
+}
diff --git a/ld/testsuite/ld-plugin/lto-16b.d b/ld/testsuite/ld-plugin/lto-16b.d
new file mode 100644
index 0000000..5c0e148
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-16b.d
@@ -0,0 +1,3 @@
+#...
+[0-9a-f]+ T bar
+#...
diff --git a/ld/testsuite/ld-plugin/lto-17a.c b/ld/testsuite/ld-plugin/lto-17a.c
new file mode 100644
index 0000000..7de81b3
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-17a.c
@@ -0,0 +1,4 @@
+void
+bar (void)
+{
+}
diff --git a/ld/testsuite/ld-plugin/lto-17a.d b/ld/testsuite/ld-plugin/lto-17a.d
new file mode 100644
index 0000000..5c0e148
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-17a.d
@@ -0,0 +1,3 @@
+#...
+[0-9a-f]+ T bar
+#...
diff --git a/ld/testsuite/ld-plugin/lto-17b-1.d b/ld/testsuite/ld-plugin/lto-17b-1.d
new file mode 100644
index 0000000..c8f4339
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-17b-1.d
@@ -0,0 +1,4 @@
+#failif
+#...
+[0-9a-f]+ . bar
+#...
diff --git a/ld/testsuite/ld-plugin/lto-17b-2.d b/ld/testsuite/ld-plugin/lto-17b-2.d
new file mode 100644
index 0000000..76ff1f6
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-17b-2.d
@@ -0,0 +1,3 @@
+#...
+[0-9a-f]+ T foo
+#...
diff --git a/ld/testsuite/ld-plugin/lto-17b.c b/ld/testsuite/ld-plugin/lto-17b.c
new file mode 100644
index 0000000..f129c90
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-17b.c
@@ -0,0 +1,6 @@
+extern void bar(void) __attribute__((__visibility__("hidden")));
+
+void foo (void)
+{
+  bar ();
+}
diff --git a/ld/testsuite/ld-plugin/lto-1a.c b/ld/testsuite/ld-plugin/lto-1a.c
new file mode 100644
index 0000000..b775d0a
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-1a.c
@@ -0,0 +1,4 @@
+unsigned long long bar (unsigned long long y)
+{
+  return 30 / y;
+}
diff --git a/ld/testsuite/ld-plugin/lto-1b.c b/ld/testsuite/ld-plugin/lto-1b.c
new file mode 100644
index 0000000..8a961ef
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-1b.c
@@ -0,0 +1,8 @@
+extern unsigned long long bar (unsigned long long);
+
+int
+main (int argc, char **argv)
+{
+  unsigned long long d = bar ((unsigned long long) (argc + 1));
+  return d;
+}
diff --git a/ld/testsuite/ld-plugin/lto-2.c b/ld/testsuite/ld-plugin/lto-2.c
new file mode 100644
index 0000000..f0eacf4
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-2.c
@@ -0,0 +1,11 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+int
+main (int argc, char **argv)
+{
+  int d = atoi (argv[1]);
+  printf ("%f\n", sin (d));
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-3.d b/ld/testsuite/ld-plugin/lto-3.d
new file mode 100644
index 0000000..c3a9a16
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-3.d
@@ -0,0 +1,4 @@
+#failif
+#...
+[0-9a-f]+ T foo
+#...
diff --git a/ld/testsuite/ld-plugin/lto-3.out b/ld/testsuite/ld-plugin/lto-3.out
new file mode 100644
index 0000000..a69f8f3
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-3.out
@@ -0,0 +1,2 @@
+hello foo
+hello bar
diff --git a/ld/testsuite/ld-plugin/lto-3a.c b/ld/testsuite/ld-plugin/lto-3a.c
new file mode 100644
index 0000000..5193972
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-3a.c
@@ -0,0 +1,9 @@
+extern void foo(void);
+extern void bar(void);
+
+int main(void)
+{
+  foo();
+  bar();
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-3b.c b/ld/testsuite/ld-plugin/lto-3b.c
new file mode 100644
index 0000000..c24f6d4
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-3b.c
@@ -0,0 +1,6 @@
+#include <stdio.h>
+
+void foo(void)
+{
+  printf ("hello foo\n");
+}
diff --git a/ld/testsuite/ld-plugin/lto-3c.c b/ld/testsuite/ld-plugin/lto-3c.c
new file mode 100644
index 0000000..95b3bc0
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-3c.c
@@ -0,0 +1,6 @@
+#include <stdio.h>
+
+void bar(void)
+{
+  printf ("hello bar\n");
+}
diff --git a/ld/testsuite/ld-plugin/lto-3r.d b/ld/testsuite/ld-plugin/lto-3r.d
new file mode 100644
index 0000000..1d1befe
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-3r.d
@@ -0,0 +1,7 @@
+#ld: -r tmpdir/lto-3b.o
+#source: dummy.s
+#nm: -p
+
+#...
+[0-9a-f]+ C __gnu_lto_v.*
+#pass
diff --git a/ld/testsuite/ld-plugin/lto-4.out b/ld/testsuite/ld-plugin/lto-4.out
new file mode 100644
index 0000000..8d8cc92
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4.out
@@ -0,0 +1,2 @@
+hello bar
+hello foo
diff --git a/ld/testsuite/ld-plugin/lto-4a.c b/ld/testsuite/ld-plugin/lto-4a.c
new file mode 100644
index 0000000..2d07cf5
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4a.c
@@ -0,0 +1,7 @@
+extern void foo(void);
+
+int main(void)
+{
+  foo();
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-4b.c b/ld/testsuite/ld-plugin/lto-4b.c
new file mode 100644
index 0000000..bb4a68b
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4b.c
@@ -0,0 +1,9 @@
+#include <stdio.h>
+
+extern void bar (void);
+
+void foo(void)
+{
+  bar ();
+  printf ("hello foo\n");
+}
diff --git a/ld/testsuite/ld-plugin/lto-4c.c b/ld/testsuite/ld-plugin/lto-4c.c
new file mode 100644
index 0000000..317e6fc
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4c.c
@@ -0,0 +1,6 @@
+#include <stdio.h>
+
+void bar (void)
+{
+  printf ("hello bar\n");
+}
diff --git a/ld/testsuite/ld-plugin/lto-4r-a.d b/ld/testsuite/ld-plugin/lto-4r-a.d
new file mode 100644
index 0000000..c618cff
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4r-a.d
@@ -0,0 +1,7 @@
+#ld: -r tmpdir/lto-4a.o tmpdir/lto-4b.o tmpdir/lto-4c.o
+#source: dummy.s
+#objdump: -h
+
+#...
+.* .gnu_object_only.*
+#pass
diff --git a/ld/testsuite/ld-plugin/lto-4r-b.d b/ld/testsuite/ld-plugin/lto-4r-b.d
new file mode 100644
index 0000000..07d71cb
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4r-b.d
@@ -0,0 +1,7 @@
+#ld: -r tmpdir/lto-4a.o tmpdir/lto-4b.o
+#source: dummy.s
+#objdump: -h
+
+#...
+.* .gnu_object_only.*
+#pass
diff --git a/ld/testsuite/ld-plugin/lto-4r-c.d b/ld/testsuite/ld-plugin/lto-4r-c.d
new file mode 100644
index 0000000..ada50c0
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4r-c.d
@@ -0,0 +1,7 @@
+#ld: -r tmpdir/lto-4r-b.o tmpdir/lto-4c.o
+#source: dummy.s
+#objdump: -h
+
+#...
+.* .gnu_object_only.*
+#pass
diff --git a/ld/testsuite/ld-plugin/lto-4r-d.d b/ld/testsuite/ld-plugin/lto-4r-d.d
new file mode 100644
index 0000000..d4c5852
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-4r-d.d
@@ -0,0 +1,7 @@
+#ld: -r --whole-archive tmpdir/liblto-4.a
+#source: dummy.s
+#objdump: -h
+
+#...
+.* .gnu_object_only.*
+#pass
diff --git a/ld/testsuite/ld-plugin/lto-5.d b/ld/testsuite/ld-plugin/lto-5.d
new file mode 100644
index 0000000..c3a9a16
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-5.d
@@ -0,0 +1,4 @@
+#failif
+#...
+[0-9a-f]+ T foo
+#...
diff --git a/ld/testsuite/ld-plugin/lto-5.out b/ld/testsuite/ld-plugin/lto-5.out
new file mode 100644
index 0000000..dfbb215
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-5.out
@@ -0,0 +1 @@
+hello foo
diff --git a/ld/testsuite/ld-plugin/lto-5a.c b/ld/testsuite/ld-plugin/lto-5a.c
new file mode 100644
index 0000000..2d07cf5
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-5a.c
@@ -0,0 +1,7 @@
+extern void foo(void);
+
+int main(void)
+{
+  foo();
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-5b.c b/ld/testsuite/ld-plugin/lto-5b.c
new file mode 100644
index 0000000..c24f6d4
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-5b.c
@@ -0,0 +1,6 @@
+#include <stdio.h>
+
+void foo(void)
+{
+  printf ("hello foo\n");
+}
diff --git a/ld/testsuite/ld-plugin/lto-5r.d b/ld/testsuite/ld-plugin/lto-5r.d
new file mode 100644
index 0000000..43e9a5c
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-5r.d
@@ -0,0 +1,7 @@
+#ld: -r tmpdir/lto-5a.o tmpdir/lto-5b.o
+#source: dummy.s
+#nm: -p
+
+#...
+[0-9a-f]+ C __gnu_lto_v.*
+#pass
diff --git a/ld/testsuite/ld-plugin/lto-6.c b/ld/testsuite/ld-plugin/lto-6.c
new file mode 100644
index 0000000..749e4e0
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-6.c
@@ -0,0 +1,9 @@
+#include <stdio.h>
+
+extern char _etext[];
+
+int main(void)
+{
+  printf ("%p: %d\n", _etext, _etext[0]);
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-7.out b/ld/testsuite/ld-plugin/lto-7.out
new file mode 100644
index 0000000..d86bac9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-7.out
@@ -0,0 +1 @@
+OK
diff --git a/ld/testsuite/ld-plugin/lto-7a.c b/ld/testsuite/ld-plugin/lto-7a.c
new file mode 100644
index 0000000..d277a43
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-7a.c
@@ -0,0 +1,14 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+int foo = -1;
+
+extern void bar ();
+
+int
+main (int argc, char **argv)
+{
+  bar ();
+  printf ("OK\n");
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-7b.c b/ld/testsuite/ld-plugin/lto-7b.c
new file mode 100644
index 0000000..1798130
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-7b.c
@@ -0,0 +1,8 @@
+extern int foo;
+
+static void
+__attribute__ ((unused, constructor))
+set_foo (void)
+{
+  foo = 30;
+}
diff --git a/ld/testsuite/ld-plugin/lto-7c.c b/ld/testsuite/ld-plugin/lto-7c.c
new file mode 100644
index 0000000..5236f57
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-7c.c
@@ -0,0 +1,9 @@
+extern int foo;
+extern int foo2;
+
+static void
+__attribute__ ((unused, constructor))
+set_foo (void)
+{
+  foo = foo2;
+}
diff --git a/ld/testsuite/ld-plugin/lto-7d.c b/ld/testsuite/ld-plugin/lto-7d.c
new file mode 100644
index 0000000..7fc1ff1
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-7d.c
@@ -0,0 +1,11 @@
+#include <stdlib.h>
+
+extern int foo;
+int foo2 = 2;
+
+void
+bar (void)
+{
+  if (foo != 30)
+    abort ();
+}
diff --git a/ld/testsuite/ld-plugin/lto-8.out b/ld/testsuite/ld-plugin/lto-8.out
new file mode 100644
index 0000000..35c5d69
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-8.out
@@ -0,0 +1 @@
+baz: 42
diff --git a/ld/testsuite/ld-plugin/lto-8a.c b/ld/testsuite/ld-plugin/lto-8a.c
new file mode 100644
index 0000000..6901fb3
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-8a.c
@@ -0,0 +1,12 @@
+#include <stdio.h>
+
+void baz(int i)
+{ 
+  printf ("baz: %d\n", i);
+}
+
+int main(void)
+{
+  foo(42);
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-8b.c b/ld/testsuite/ld-plugin/lto-8b.c
new file mode 100644
index 0000000..3b6db5f
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-8b.c
@@ -0,0 +1,14 @@
+extern int bar(void) __attribute__((__visibility__("hidden"), __const__));
+extern void baz(int);
+
+void foo(char c)
+{
+  int i;
+
+  if (bar())
+    i = c;
+  else
+    i = c;
+
+  baz(i);
+}
diff --git a/ld/testsuite/ld-plugin/lto-9.cc b/ld/testsuite/ld-plugin/lto-9.cc
new file mode 100644
index 0000000..2a4dcde
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-9.cc
@@ -0,0 +1,9 @@
+struct Foooo {
+  virtual ~Foooo () { }
+};
+
+int main(void)
+{
+  Foooo t;
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/lto-9.d b/ld/testsuite/ld-plugin/lto-9.d
new file mode 100644
index 0000000..4b5bcf8
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto-9.d
@@ -0,0 +1,4 @@
+#failif
+#...
+[0-9a-f]+ . .*Foooo::Foooo.*
+#...
diff --git a/ld/testsuite/ld-plugin/lto.exp b/ld/testsuite/ld-plugin/lto.exp
new file mode 100644
index 0000000..7554c75
--- /dev/null
+++ b/ld/testsuite/ld-plugin/lto.exp
@@ -0,0 +1,342 @@
+# Expect script for ld-plugin LTO tests
+#   Copyright 2011
+#   Free Software Foundation, Inc.
+#
+# This file is part of the GNU Binutils.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+# MA 02110-1301, USA.
+
+# These tests require plugin and LTO.
+if { ![check_plugin_api_available]
+     || ![check_lto_available] } {
+    return
+}
+
+# Simple LTO tests and generate input files for complex LTO tests.
+set lto_link_tests {
+  {"LTO 1"
+   "-O2 -flto -fuse-linker-plugin" "-flto -fuse-linker-plugin"
+   {lto-1a.c lto-1b.c} {} "lto-1.exe"}
+  {"Build libdummy.a 2"
+   "" "-O2 -flto -fuse-linker-plugin"
+   {lto-2.c} {} "libdummy.a"}
+  {"LTO 2"
+   "-static -O2 -flto -fuse-linker-plugin tmpdir/lto-2.o -lm" ""
+   {dummy.c} {} "lto-2.exe"}
+  {"Build libdummy.a 3a"
+   "" "-flto"
+   {lto-3a.c} {} "libdummy.a"}
+  {"Build libdummy.a 3c"
+   "" "-O2"
+   {lto-3c.c} {} "libdummy.a"}
+  {"Build liblto-3.a"
+   "" "-flto"
+   {lto-3b.c} {} "liblto-3.a"}
+  {"Build libdummy.a 4a"
+   "" "-flto"
+   {lto-4a.c} {} "libdummy.a"}
+  {"Build libdummy.a 4b"
+   "" "-O2"
+   {lto-4b.c} {} "libdummy.a"}
+  {"Build libdummy.a 4c"
+   "" "-O2"
+   {lto-4c.c} {} "libdummy.a"}
+  {"Build libdummy.a 5a"
+   "" "-flto"
+   {lto-5a.c} {} "libdummy.a"}
+  {"Build libdummy.a 5b"
+   "" "-flto"
+   {lto-5b.c} {} "libdummy.a"}
+  {"LTO 6"
+   "-O2 -flto -fuse-linker-plugin" ""
+   {lto-6.c} {} "lto-6.exe" "c"}
+  {"Build libdummy.a PR ld/12365"
+   "" "-flto -O2"
+   {pr12365a.c pr12365b.c pr12365c.c} {} "libdummy.a"}
+  {"Build libdummy.a 9"
+   "" "-O2 -flto"
+   {lto-9.cc} {} "libdummy.a"}
+  {"Build libdummy.a 10a"
+   "" "-O2"
+   {lto-10a.c} {} "libdummy.a"}
+  {"Build libdummy.a 10b"
+   "" "-O2 -flto"
+   {lto-10b.c} {} "libdummy.a"}
+  {"Build libdummy.a 11a"
+   "" "-O -flto"
+   {lto-11a.c} {} "libdummy.a"}
+  {"Build libdummy.a 11b"
+   "" "-O -flto"
+   {lto-11b.c} {} "libdummy.a"}
+  {"Build libdummy.a 11c"
+   "" "-O"
+   {lto-11c.c} {} "libdummy.a"}
+  {"Build liblto-12.a"
+   "" "-O2 -flto"
+   {lto-12c.c} {} "liblto-12.a"}
+  {"Build libdummy.a 12"
+   "" "-O2 -flto"
+   {lto-12a.c lto-12b.c} {} "libdummy.a"}
+  {"Build libdummy.a 13"
+   "" "-O2 -flto"
+   {lto-13a.c lto-13b.c} {} "libdummy.a"}
+  {"Build liblto-13.a"
+   "" "-O2"
+   {lto-13c.c} {} "liblto-13.a"}
+  {"Build libdummy.a 14a"
+   "" "-flto"
+   {lto-14a.c lto-14b.c} {} "libdummy.a"}
+  {"Build liblto-14.a"
+   "" "-flto"
+   {lto-14c.c} {} "liblto-14.a"}
+  {"Build libdummy.a 15a"
+   "" "-flto"
+   {lto-15a.c} {} "libdummy.a"}
+  {"Build liblto-15.a"
+   "" "-flto"
+   {lto-15b.c} {} "liblto-15.a"}
+  {"PR ld/12696"
+   "-O2 -flto -fuse-linker-plugin -r -nostdlib" "-O2 -flto"
+   {pr12696-1.cc} {} "pr12696-1r.o" "c"}
+  {"Build libdummy.a PR ld/12758"
+   "" ""
+   {pr12758a.s} {} "libdummy.a"}
+  {"Build libpr12758.a"
+   "" "-flto -O2"
+   {pr12758b.c} {} "libpr12758.a"}
+  {"PR ld/12758"
+   "-O2 -Wl,-e,foo -nostdlib -flto -fuse-linker-plugin tmpdir/pr12758a.o -Wl,--start-group tmpdir/libpr12758.a -Wl,--end-group" ""
+   {dummy.c} {} "pr12758.exe"}
+  {"Build libdummy.a PR ld/12760"
+   "" ""
+   {pr12760a.c} {} "libdummy.a"}
+  {"Build libpr12760.a"
+   "" "-flto -O2"
+   {pr12760b.c} {} "libpr12760.a"}
+  {"PR ld/12760"
+   "-O2 -Wl,-e,foo -nostdlib -flto -fuse-linker-plugin tmpdir/pr12760a.o -Wl,--start-group tmpdir/libpr12760.a -Wl,--end-group" ""
+   {dummy.c} {} "pr12760.exe"}
+  {"Build libdummy.a PR ld/12942 (1)"
+   "" "-flto -O2"
+   {pr12942a.cc pr12942c.cc} {} "libdummy.a" "c++"}
+  {"Build libdummy.a PR ld/12942 (2)"
+   "" "-O0"
+   {pr12942b.cc} {} "libdummy.a" "c++"}
+  {"Build libpr13183.a"
+   "-T" "-flto -O2"
+   {pr13183a.c} {} "libpr13183.a"}
+  {"Build libdummy.a PR ld/13183"
+   "" "-flto -O2"
+   {pr13183b.c} {} "libdummy.a"}
+  {"Build libdummy.a PR ld/13201"
+   "" "-flto -O2"
+   {pr13201.c} {} "libdummy.a"}
+  {"PR ld/13287"
+   "-flto -fuse-linker-plugin -Wl,--as-needed" "-flto"
+   {pr13287.cc} {} "pr13287.exe" "c++"}
+}
+
+# Generate input files for complex LTO tests for ELF.
+set lto_link_elf_tests {
+  {"Build libdummy.a 7"
+   "" "-flto -O2"
+   {lto-7a.c lto-7b.c lto-7c.c} {} "libdummy.a"}
+  {"Build liblto-7.so"
+   "-shared" "-O2 -fpic"
+   {lto-7d.c} {} "liblto-7.so" "c"}
+  {"Build libdummy.a 8a"
+   "" "-O2"
+   {lto-8a.c} {} "libdummy.a"}
+  {"Build libdummy.a 8b"
+   "" "-flto -O2"
+   {lto-8b.c} {} "libdummy.a"}
+  {"Build liblto-17a.so"
+   "-shared -O2 -fpic -flto -fuse-linker-plugin" "-O2 -fpic -flto"
+   {lto-17a.c} {{"nm" {} "lto-17a.d"}} "liblto-17a.so" "c"}
+  {"Build liblto-17b.so 1"
+   "-shared -O2 -fpic -flto -fuse-linker-plugin tmpdir/lto-17a.o" "-O2 -fpic -flto"
+   {lto-17b.c} {{"nm" {} "lto-17b-1.d"}} "liblto-17b.so"}
+  {"Build liblto-17b.so 2"
+   "-shared -O2 -fpic -flto -fuse-linker-plugin tmpdir/lto-17a.o" "-O2 -fpic -flto"
+   {lto-17b.c} {{"nm" {} "lto-17b-2.d"}} "liblto-17b.so"}
+  {"PR ld/12982"
+   "-O2 -flto -fuse-linker-plugin" "-O2 -flto"
+   {pr12982.c} {{"readelf" {-l --wide} "pr12982.d"}} "pr12982.exe"}
+  {"PR ld/12975"
+   "-shared -O2 -fPIC -flto -fuse-linker-plugin -nostdlib -Wl,-version-script,pr12975.t" "-O2 -flto"
+   {pr12975.c} {{"readelf" {-s --wide} "pr12975.d"}} "pr12975.so" "c"}
+  {"PR ld/13229"
+   "-shared -O2 -fPIC -flto -fuse-linker-plugin -nostdlib" "-O2 -fno-early-inlining -flto"
+   {pr13229.cc} {{"readelf" {-s --wide} "pr13229.d"}} "pr13229.so" "c++"}
+  {"PR ld/13244"
+   "-shared -O2 -fPIC -flto -fuse-linker-plugin -nostdlib" "-O2 -fno-early-inlining -flto"
+   {pr13244.c} {{"readelf" {-s --wide} "pr13244.d"}} "pr13244.so" "c"}
+}
+
+# Check final symbols in executables.
+set lto_link_symbol_tests {
+  {"LTO 3 symbol"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-3a.o tmpdir/lto-3c.o tmpdir/liblto-3.a" ""
+   {dummy.c} {{"nm" {} "lto-3.d"}} "lto-3.exe" "c"}
+  {"LTO 5 symbol"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-5.o" ""
+   {dummy.c} {{"nm" {} "lto-5.d"}} "lto-5.exe" "c"}
+  {"LTO 9 symbol"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-9.o" ""
+   {dummy.c} {{"nm" {-C} "lto-9.d"}} "lto-9.exe" "c++"}
+  {"LTO 16a symbol"
+   "-O2 -Wl,-e,foo -nostdlib -flto -fuse-linker-plugin" "-flto"
+   {lto-16a.c} {{"nm" {} "lto-16a.d"}} "lto-16.exe" "c"}
+  {"LTO 16b symbol"
+   "-O2 -Wl,-e,foo -u bar -nostdlib -flto -fuse-linker-plugin" "-flto"
+   {lto-16a.c lto-16b.c} {{"nm" {} "lto-16b.d"}} "lto-16b.exe" "c"}
+  {"PR ld/13183"
+   "-O2 -flto -fuse-linker-plugin tmpdir/pr13183b.o tmpdir/libpr13183.a" ""
+   {dummy.c} {{"nm" {} "pr13183.d"}} "pr13183.exe" "c"}
+}
+
+# LTO run-time tests.
+set lto_run_tests {
+  {"LTO 3a"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-3a.o tmpdir/lto-3c.o tmpdir/liblto-3.a" ""
+   {dummy.c} "lto-3b.exe" "lto-3.out" "" "c"}
+  {"LTO 3b"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-3a.o tmpdir/lto-3c.o tmpdir/lto-3.o" ""
+   {dummy.c} "lto-3c.exe" "lto-3.out" "" "c"}
+  {"LTO 3c"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-3a.o tmpdir/lto-3c.o -Wl,--whole-archive tmpdir/liblto-3.a -Wl,--no-whole-archive tmpdir/liblto-3.a" ""
+   {dummy.c} "lto-3d.exe" "lto-3.out" "" "c"}
+  {"LTO 4a"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-4r-a.o" ""
+   {dummy.c} "lto-4a.exe" "lto-4.out" "" "c"}
+  {"LTO 4c"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-4r-c.o" ""
+   {dummy.c} "lto-4c.exe" "lto-4.out" "" "c"}
+  {"LTO 4d"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-4r-d.o" ""
+   {dummy.c} "lto-4d.exe" "lto-4.out" "" "c"}
+  {"LTO 5"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-5.o" ""
+   {dummy.c} "lto-5.exe" "lto-5.out" "" "c"}
+  {"LTO 10"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-10.o" ""
+   {dummy.c} "lto-10.exe" "lto-10.out" "" "c"}
+  {"LTO 11"
+   "-O -flto -fuse-linker-plugin tmpdir/liblto-11.a" ""
+   {dummy.c} "lto-11.exe" "lto-11.out" "" "c"}
+  {"LTO 12a"
+   "-O -flto -fuse-linker-plugin tmpdir/lto-12a.o tmpdir/liblto-12.a tmpdir/lto-12b.o" ""
+   {dummy.c} "lto-12a.exe" "lto-12.out" "" "c"}
+  {"LTO 12b"
+   "-O -flto -fuse-linker-plugin tmpdir/lto-12a.o tmpdir/lto-12b.o tmpdir/liblto-12.a" ""
+   {dummy.c} "lto-12b.exe" "lto-12.out" "" "c"}
+  {"LTO 13"
+   "-O -flto -fuse-linker-plugin tmpdir/lto-13a.o tmpdir/liblto-13.a tmpdir/lto-13b.o" ""
+   {dummy.c} "lto-13.exe" "lto-13.out" "" "c"}
+  {"LTO 14"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-14a.o -Wl,--whole-archive tmpdir/liblto-14.a -Wl,--no-whole-archive tmpdir/lto-14b.o" ""
+   {dummy.c} "lto-14.exe" "lto-14.out" "" "c"}
+  {"LTO 15"
+   "-O2 -flto -fuse-linker-plugin -Wl,--start-group tmpdir/lto-15a.o tmpdir/liblto-15.a -Wl,--end-group" ""
+   {dummy.c} "lto-15.exe" "lto-15.out" "" "c"}
+  {"PR ld/12942 (1)"
+   "-O2 -flto -fuse-linker-plugin tmpdir/pr12942a.o tmpdir/pr12942b.o" ""
+   {dummy.c} "pr12942a.exe" "pr12942.out" "" "c++"}
+  {"PR ld/12942 (2)"
+   "-O2 -flto -fuse-linker-plugin tmpdir/pr12942a.o tmpdir/pr12942c.o" ""
+   {dummy.c} "pr12942c.exe" "pr12942.out" "" "c++"}
+  {"PR ld/13066"
+   "-O2 -flto -fuse-linker-plugin" ""
+   {pr13066.cc} "pr13066.exe" "pr13066.out" "" "c++"}
+  {"PR ld/13201"
+   "-O2 -flto -fuse-linker-plugin -Wl,--as-needed tmpdir/pr13201.o -lm" ""
+   {dummy.c} "pr13201.exe" "pr13201.out" "" "c"}
+}
+
+# LTO run-time tests for ELF
+set lto_run_elf_tests {
+  {"LTO 7"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-7b.o tmpdir/lto-7c.o tmpdir/lto-7a.o tmpdir/liblto-7.so" ""
+   {dummy.c} "lto-7.exe" "lto-7.out" "" "c"}
+  {"LTO 8"
+   "-O2 -flto -fuse-linker-plugin tmpdir/lto-8b.o tmpdir/lto-8a.o" ""
+   {dummy.c} "lto-8.exe" "lto-8.out" "" "c"}
+  {"LTO TLS IE"
+   "-O2 -flto -fuse-linker-plugin" ""
+   {run-ie.c} "run-ie.exe" "run-ie.out" "" "c"}
+}
+
+run_cc_link_tests $lto_link_tests
+
+if { [is_elf_format] } {
+    run_cc_link_tests $lto_link_elf_tests
+}
+
+set testname "Build liblto-4.a"
+remote_file host delete "tmpdir/liblto-4.a"
+set catch_output [run_host_cmd "$ar" "rc tmpdir/liblto-4.a tmpdir/lto-4a.o tmpdir/lto-4b.o tmpdir/lto-4c.o"]
+if {![string match "" $catch_output]} {
+    unresolved $testname
+    return
+}
+
+set testname "Build liblto-11.a"
+remote_file host delete "tmpdir/liblto-11.a"
+set catch_output [run_host_cmd "$ar" "rc tmpdir/liblto-11.a tmpdir/lto-11a.o tmpdir/lto-11b.o tmpdir/lto-11c.o"]
+if {![string match "" $catch_output]} {
+    unresolved $testname
+    return
+}
+
+# Check expected LTO linker errors.
+set testname "PR ld/12365"
+set exec_output [run_host_cmd "$CC" "$gcc_gas_flag $gcc_ld_flag -O2 -flto -fuse-linker-plugin tmpdir/pr12365a.o tmpdir/pr12365b.o tmpdir/pr12365c.o"]
+if { [ regexp "undefined reference to `my_bcopy'" $exec_output ] } {
+    pass $testname
+} {
+    fail $testname
+}
+set testname "PR ld/12942 (3)"
+set exec_output [run_host_cmd "$CXX" "$gcc_gas_flag $gcc_ld_flag -O2 -flto -fuse-linker-plugin tmpdir/pr12942b.o tmpdir/pr12942a.o"]
+if { [ regexp "pr12942a.h:7: undefined reference to `link_error\\(\\)'" $exec_output ] } {
+    pass $testname
+} {
+    fail $testname
+}
+
+# Run "ld -r" to generate inputs for complex LTO tests.
+run_dump_test "lto-3r"
+remote_exec host "mv" "tmpdir/dump tmpdir/lto-3.o"
+run_dump_test "lto-4r-a"
+remote_exec host "mv" "tmpdir/dump tmpdir/lto-4r-a.o"
+run_dump_test "lto-4r-b"
+remote_exec host "mv" "tmpdir/dump tmpdir/lto-4r-b.o"
+run_dump_test "lto-4r-c"
+remote_exec host "mv" "tmpdir/dump tmpdir/lto-4r-c.o"
+run_dump_test "lto-4r-d"
+remote_exec host "mv" "tmpdir/dump tmpdir/lto-4r-d.o"
+run_dump_test "lto-5r"
+remote_exec host "mv" "tmpdir/dump tmpdir/lto-5.o"
+run_dump_test "lto-10r"
+remote_exec host "mv" "tmpdir/dump tmpdir/lto-10.o"
+
+run_cc_link_tests $lto_link_symbol_tests
+
+run_ld_link_exec_tests [] $lto_run_tests
+
+if { [is_elf_format] } {
+    run_ld_link_exec_tests [] $lto_run_elf_tests
+}
diff --git a/ld/testsuite/ld-plugin/plugin.exp b/ld/testsuite/ld-plugin/plugin.exp
index d28505d..803ccee 100644
--- a/ld/testsuite/ld-plugin/plugin.exp
+++ b/ld/testsuite/ld-plugin/plugin.exp
@@ -157,7 +157,11 @@ set plugin_extra_elf_tests [list \
 			-plugin-opt sym:${_}func3::0:3:0 \
 			-plugin-opt dumpresolutions \
 			-plugin-opt add:tmpdir/func.o \
-    $testobjfiles $libs --verbose=2" "" "" {{ld plugin-12.d}} "main.x" ] \
+			-plugin-opt add:tmpdir/func1p.o \
+			-plugin-opt add:tmpdir/func2i.o \
+			-plugin-opt add:tmpdir/func3h.o \
+    $testobjfiles $libs --verbose=2" "" "" {{ld plugin-12.d} \
+				{readelf -s plugin-vis-1.d}} "main.x" ] \
 ]
 
 if { !$can_compile || $failed_compile } {
@@ -174,7 +178,10 @@ if { !$can_compile || $failed_compile } {
 
 run_ld_link_tests $plugin_tests
 
-if { [is_elf_format] } {
+if { [is_elf_format] \
+     && [ld_compile "$CC $CFLAGS" $srcdir/$subdir/func1p.c tmpdir/func1p.o] \
+     && [ld_compile "$CC $CFLAGS" $srcdir/$subdir/func2i.c tmpdir/func2i.o] \
+     && [ld_compile "$CC $CFLAGS" $srcdir/$subdir/func3h.c tmpdir/func3h.o] } {
     run_ld_link_tests $plugin_extra_elf_tests
 }
 
diff --git a/ld/testsuite/ld-plugin/pr12365a.c b/ld/testsuite/ld-plugin/pr12365a.c
new file mode 100644
index 0000000..a9bb6c6
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12365a.c
@@ -0,0 +1,25 @@
+extern void abort(void);
+extern void main_test (void);
+extern void abort (void);
+int inside_main;
+
+int
+main ()
+{
+  inside_main = 1;
+  main_test ();
+  inside_main = 0;
+  return 0;
+}
+
+/* When optimizing, all the constant cases should have been
+   constant folded, so no calls to link_error should remain.
+   In any case, link_error should not be called.  */
+
+#ifndef __OPTIMIZE__
+void
+link_error (void)
+{
+  abort ();
+}
+#endif
diff --git a/ld/testsuite/ld-plugin/pr12365b.c b/ld/testsuite/ld-plugin/pr12365b.c
new file mode 100644
index 0000000..3e86e06
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12365b.c
@@ -0,0 +1,47 @@
+#define ASMNAME(cname)  ASMNAME2 (__USER_LABEL_PREFIX__, cname)
+#define ASMNAME2(prefix, cname) STRING (prefix) cname
+#define STRING(x)    #x
+
+typedef __SIZE_TYPE__ size_t;
+extern void abort (void);
+extern void *memcpy (void *, const void *, size_t)
+  __asm (ASMNAME ("my_memcpy"));
+extern void bcopy (const void *, void *, size_t)
+  __asm (ASMNAME ("my_bcopy"));
+extern void *memset (void *, int, size_t)
+  __asm (ASMNAME ("my_memset"));
+extern void bzero (void *, size_t)
+  __asm (ASMNAME ("my_bzero"));
+extern int memcmp (const void *, const void *, size_t);
+
+struct A { char c[32]; } a = { "foobar" };
+char x[64] = "foobar", y[64];
+int i = 39, j = 6, k = 4;
+
+extern int inside_main;
+
+void
+main_test (void)
+{
+  struct A b = a;
+  struct A c = { { 'x' } };
+
+  inside_main = 1;
+  
+  if (memcmp (b.c, x, 32) || c.c[0] != 'x' || memcmp (c.c + 1, x + 32, 31))
+    abort ();
+  if (__builtin_memcpy (y, x, i) != y || memcmp (x, y, 64))
+    abort ();
+  if (memcpy (y + 6, x, j) != y + 6
+      || memcmp (x, y, 6) || memcmp (x, y + 6, 58))
+    abort ();
+  if (__builtin_memset (y + 2, 'X', k) != y + 2
+      || memcmp (y, "foXXXXfoobar", 13))
+    abort ();
+  bcopy (y + 1, y + 2, 6);
+  if (memcmp (y, "fooXXXXfobar", 13))
+    abort ();
+  __builtin_bzero (y + 4, 2);
+  if (memcmp (y, "fooX\0\0Xfobar", 13))
+    abort ();
+}
diff --git a/ld/testsuite/ld-plugin/pr12365c.c b/ld/testsuite/ld-plugin/pr12365c.c
new file mode 100644
index 0000000..2edd0ff
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12365c.c
@@ -0,0 +1,79 @@
+extern void abort (void);
+extern int inside_main;
+typedef __SIZE_TYPE__ size_t;
+
+#define TEST_ABORT if (inside_main) abort()
+
+void *
+my_memcpy (void *d, const void *s, size_t n)
+{
+  char *dst = (char *) d;
+  const char *src = (const char *) s;
+  while (n--)
+    *dst++ = *src++;
+  return (char *) d;
+}
+
+void
+my_bcopy (const void *s, void *d, size_t n)
+{
+  char *dst = (char *) d;
+  const char *src = (const char *) s;
+  if (src >= dst)
+    while (n--)
+      *dst++ = *src++;
+  else
+    {
+      dst += n;
+      src += n;
+      while (n--)
+        *--dst = *--src;
+    }
+}
+
+void *
+my_memset (void *d, int c, size_t n)
+{
+  char *dst = (char *) d;
+  while (n--)
+    *dst++ = c;
+  return (char *) d;
+}
+
+void
+my_bzero (void *d, size_t n)
+{
+  char *dst = (char *) d;
+  while (n--)
+    *dst++ = '\0';
+}
+
+void *
+memcpy (void *d, const void *s, size_t n)
+{
+  void *result = my_memcpy (d, s, n);
+  TEST_ABORT;
+  return result;
+}
+
+void
+bcopy (const void *s, void *d, size_t n)
+{
+  my_bcopy (s, d, n);
+  TEST_ABORT;
+}
+
+void *
+memset (void *d, int c, size_t n)
+{
+  void *result = my_memset (d, c, n);
+  TEST_ABORT;
+  return result;
+}
+
+void
+bzero (void *d, size_t n)
+{
+  my_bzero (d, n);
+  TEST_ABORT;
+}
diff --git a/ld/testsuite/ld-plugin/pr12696-1.cc b/ld/testsuite/ld-plugin/pr12696-1.cc
new file mode 100644
index 0000000..084c07f
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12696-1.cc
@@ -0,0 +1,7 @@
+/* { dg-lto-do link } */
+/* { dg-lto-options {{-ftoplevel-reorder -flto -flto-partition=none} {-ftoplevel-reorder -flto -flto-partition=1to1}} } */
+/* { dg-extra-ld-options {-r -nostdlib} } */
+
+struct Foo { virtual ~Foo(); };
+struct Bar:public Foo { Bar() { } };
+void Func() { new Bar(); }
diff --git a/ld/testsuite/ld-plugin/pr12758a.s b/ld/testsuite/ld-plugin/pr12758a.s
new file mode 100644
index 0000000..04409d0
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12758a.s
@@ -0,0 +1,4 @@
+	.text
+	.globl foo
+foo:
+	.dc.a  memcmp
diff --git a/ld/testsuite/ld-plugin/pr12758b.c b/ld/testsuite/ld-plugin/pr12758b.c
new file mode 100644
index 0000000..5bcf116
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12758b.c
@@ -0,0 +1,12 @@
+#include <string.h>
+
+int memcmp(const void *cs, const void *ct, size_t count)
+{
+ const unsigned char *su1, *su2;
+ int res = 0;
+
+ for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+  if ((res = *su1 - *su2) != 0)
+   break;
+ return res;
+}
diff --git a/ld/testsuite/ld-plugin/pr12760a.c b/ld/testsuite/ld-plugin/pr12760a.c
new file mode 100644
index 0000000..6169c26
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12760a.c
@@ -0,0 +1,7 @@
+extern void bar ();
+
+void
+foo ()
+{
+  bar ();
+}
diff --git a/ld/testsuite/ld-plugin/pr12760b.c b/ld/testsuite/ld-plugin/pr12760b.c
new file mode 100644
index 0000000..29a9fd8
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12760b.c
@@ -0,0 +1,7 @@
+#define linker_warning(x, msg) \
+	static const char __warn_##x[] \
+	__attribute__((used, section(".gnu.warning." #x))) \
+	= msg
+
+void bar (void) {} 
+linker_warning(bar, "Bad bar"); 
diff --git a/ld/testsuite/ld-plugin/pr12942.out b/ld/testsuite/ld-plugin/pr12942.out
new file mode 100644
index 0000000..d86bac9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12942.out
@@ -0,0 +1 @@
+OK
diff --git a/ld/testsuite/ld-plugin/pr12942a.cc b/ld/testsuite/ld-plugin/pr12942a.cc
new file mode 100644
index 0000000..1a18404
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12942a.cc
@@ -0,0 +1,16 @@
+#include <stdio.h>
+#include "pr12942a.h"
+
+extern "C" void abort ();
+
+test_t b(void);
+
+int
+main(void)
+{
+  if (test != b ())
+    abort ();
+
+  printf ("OK\n");
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/pr12942a.h b/ld/testsuite/ld-plugin/pr12942a.h
new file mode 100644
index 0000000..760929b
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12942a.h
@@ -0,0 +1,12 @@
+extern void link_error ();
+
+inline int test (void)
+{
+  int exp = -1;
+  if ((exp < 2 ? 2U : (unsigned int) exp) != 2)
+    link_error ();
+
+  return 0;
+}
+
+typedef int (*test_t) (void);
diff --git a/ld/testsuite/ld-plugin/pr12942b.cc b/ld/testsuite/ld-plugin/pr12942b.cc
new file mode 100644
index 0000000..387954e
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12942b.cc
@@ -0,0 +1,7 @@
+#include <stdio.h>
+#include "pr12942a.h"
+
+test_t b(void)
+{
+  return test;
+}
diff --git a/ld/testsuite/ld-plugin/pr12942c.cc b/ld/testsuite/ld-plugin/pr12942c.cc
new file mode 100644
index 0000000..9b07231
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12942c.cc
@@ -0,0 +1 @@
+#include "pr12942b.cc"
diff --git a/ld/testsuite/ld-plugin/pr12975.c b/ld/testsuite/ld-plugin/pr12975.c
new file mode 100644
index 0000000..909af97
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12975.c
@@ -0,0 +1,7 @@
+int foo() { return 42; }
+
+int bar() { return 0; }
+
+#pragma GCC visibility push(hidden)
+int baz() { return 1; }
+#pragma GCC visibility pop
diff --git a/ld/testsuite/ld-plugin/pr12975.d b/ld/testsuite/ld-plugin/pr12975.d
new file mode 100644
index 0000000..7fcff80
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12975.d
@@ -0,0 +1,4 @@
+#failif
+#...
+ +[0-9]+: +[0-9a-f]+ +[0-9]+ +FUNC +LOCAL +DEFAULT +[1-9]+ bar
+#...
diff --git a/ld/testsuite/ld-plugin/pr12975.t b/ld/testsuite/ld-plugin/pr12975.t
new file mode 100644
index 0000000..902c1f7
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12975.t
@@ -0,0 +1,6 @@
+{
+global:
+  foo;
+local:
+  *;
+};
diff --git a/ld/testsuite/ld-plugin/pr12982.c b/ld/testsuite/ld-plugin/pr12982.c
new file mode 100644
index 0000000..398ec67
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12982.c
@@ -0,0 +1,5 @@
+int
+main (void)
+{
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/pr12982.d b/ld/testsuite/ld-plugin/pr12982.d
new file mode 100644
index 0000000..f536d5b
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr12982.d
@@ -0,0 +1,3 @@
+#...
+[ \t]+GNU_STACK[ \t]+0x[0-9a-f]+ +0x[0-9a-f]+ +0x[0-9a-f]+ +0x[0-9a-f]+ +0x[0-9a-f]+ +RW +0x[0-9a-f]+
+#pass
diff --git a/ld/testsuite/ld-plugin/pr13066.cc b/ld/testsuite/ld-plugin/pr13066.cc
new file mode 100644
index 0000000..b2c73f2
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13066.cc
@@ -0,0 +1,85 @@
+#include <stdio.h>
+
+template <typename V> struct S
+{
+  V *f, *l;
+  __attribute__ ((noinline)) S (void) { f = 0, l = 0; }
+  void foo (V *x)
+  {
+    if (x->p != 0)
+      x->p->n = x->n;
+    else
+      f = x->n;
+    if (x->n != 0)
+      x->n->p = x->p;
+    else
+      l = x->p;
+  }
+  __attribute__ ((noinline)) void bar (V *x)
+  {
+    x->n = 0;
+    x->p = l;
+    if (l != 0)
+      l->n = x;
+    else
+      f = x;
+    l = x;
+  }
+};
+
+struct H;
+
+struct A
+{
+  S <H> k;
+};
+
+struct H
+{
+  A *a;
+  H *p, *n;
+  __attribute__ ((noinline)) H (void) { p = 0, n = 0, a = 0; }
+  __attribute__ ((noinline)) H (A *b) : a (b)
+  {
+    p = 0;
+    n = 0;
+    if (a != 0)
+      a->k.bar (this);
+  }
+  __attribute__ ((noinline)) H (const H &h) : a (h.a)
+  {
+    p = 0;
+    n = 0;
+    if (a != 0)
+      a->k.bar (this);
+  }
+  ~H (void) { if (a != 0) a->k.foo (this); }
+  H &operator= (const H &o)
+  {
+    if (a != 0 || &o == this)
+      __builtin_abort ();
+    a = o.a;
+    if (a != 0)
+      a->k.bar (this);
+    return *this;
+  }
+};
+
+__attribute__ ((noinline))
+H baz (void)
+{
+  return H (new A);
+}
+
+H g;
+
+int
+main (void)
+{
+  g = baz ();
+  if (g.a->k.f != &g)
+    __builtin_abort ();
+  printf ("OK\n");
+  return 0;
+}
+
diff --git a/ld/testsuite/ld-plugin/pr13066.out b/ld/testsuite/ld-plugin/pr13066.out
new file mode 100644
index 0000000..d86bac9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13066.out
@@ -0,0 +1 @@
+OK
diff --git a/ld/testsuite/ld-plugin/pr13183.d b/ld/testsuite/ld-plugin/pr13183.d
new file mode 100644
index 0000000..a390282
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13183.d
@@ -0,0 +1,4 @@
+#failif
+#...
+[0-9a-f]+ . foo
+#...
diff --git a/ld/testsuite/ld-plugin/pr13183a.c b/ld/testsuite/ld-plugin/pr13183a.c
new file mode 100644
index 0000000..c83d856
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13183a.c
@@ -0,0 +1,4 @@
+int foo(void)
+{
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/pr13183b.c b/ld/testsuite/ld-plugin/pr13183b.c
new file mode 100644
index 0000000..93d57b5
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13183b.c
@@ -0,0 +1,6 @@
+extern int foo(void);
+
+int main(void)
+{
+  return foo();
+}
diff --git a/ld/testsuite/ld-plugin/pr13201.c b/ld/testsuite/ld-plugin/pr13201.c
new file mode 100644
index 0000000..8cfc50c
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13201.c
@@ -0,0 +1,16 @@
+#include <math.h>
+#include <stdio.h>
+
+int
+main(int argc, char **argv)
+{
+  double x;
+  if (argc > 1)
+    x = atof (argv[1]);
+  else
+    x = 3;
+  x = sin (x);
+  if (x > 0)
+    printf("OK\n");
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/pr13201.out b/ld/testsuite/ld-plugin/pr13201.out
new file mode 100644
index 0000000..d86bac9
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13201.out
@@ -0,0 +1 @@
+OK
diff --git a/ld/testsuite/ld-plugin/pr13229.cc b/ld/testsuite/ld-plugin/pr13229.cc
new file mode 100644
index 0000000..f584982
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13229.cc
@@ -0,0 +1,15 @@
+int call_something (int);
+inline void optimize_me_out (void)                                              
+{ 
+  call_something(0);
+}
+__attribute__ ((visibility("hidden")))
+int optimize_me_out2 (int param)                                                
+{ 
+  if ((void *)optimize_me_out != (void *)call_something)
+    return call_something(0);                                                   
+}
+void test2 (void)
+{ 
+  optimize_me_out();
+}
diff --git a/ld/testsuite/ld-plugin/pr13229.d b/ld/testsuite/ld-plugin/pr13229.d
new file mode 100644
index 0000000..017a716
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13229.d
@@ -0,0 +1,4 @@
+#failif
+#...
+.*optimize_me_out.*
+#...
diff --git a/ld/testsuite/ld-plugin/pr13244.c b/ld/testsuite/ld-plugin/pr13244.c
new file mode 100644
index 0000000..0d6d14a
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13244.c
@@ -0,0 +1,13 @@
+extern __attribute__ ((visibility("hidden"))) int fooblah;
+
+static
+do_nothing (int param)
+{ 
+  if (param)
+   fooblah = 1;
+}
+
+bar ()
+{ 
+  do_nothing (0);
+}
diff --git a/ld/testsuite/ld-plugin/pr13244.d b/ld/testsuite/ld-plugin/pr13244.d
new file mode 100644
index 0000000..59bbe4d
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13244.d
@@ -0,0 +1,4 @@
+#failif
+#...
+.*fooblah.*
+#...
diff --git a/ld/testsuite/ld-plugin/pr13287.cc b/ld/testsuite/ld-plugin/pr13287.cc
new file mode 100644
index 0000000..67e8506
--- /dev/null
+++ b/ld/testsuite/ld-plugin/pr13287.cc
@@ -0,0 +1 @@
+int main() {return 0; }
diff --git a/ld/testsuite/ld-plugin/run-ie.c b/ld/testsuite/ld-plugin/run-ie.c
new file mode 100644
index 0000000..32afa0a
--- /dev/null
+++ b/ld/testsuite/ld-plugin/run-ie.c
@@ -0,0 +1,32 @@
+#include <stdio.h>
+
+extern void abort (void);
+
+__thread int tls_ie __attribute__((tls_model("initial-exec"))) = 4;
+
+int get_ie (void)
+{
+  return tls_ie;
+}
+
+int *get_iep (void)
+{
+  return &tls_ie;
+}
+
+int main (void)
+{
+  int val;
+
+  val = get_ie ();
+  if (val != 4)
+    abort ();
+
+  val = *get_iep ();
+  if (val != 4)
+    abort ();
+
+  printf ("IE: %d\n", val);
+
+  return 0;
+}
diff --git a/ld/testsuite/ld-plugin/run-ie.out b/ld/testsuite/ld-plugin/run-ie.out
new file mode 100644
index 0000000..7edca6d
--- /dev/null
+++ b/ld/testsuite/ld-plugin/run-ie.out
@@ -0,0 +1 @@
+IE: 4
diff --git a/ld/testsuite/lib/ld-lib.exp b/ld/testsuite/lib/ld-lib.exp
index a481ce7..8d1ea2f 100644
--- a/ld/testsuite/lib/ld-lib.exp
+++ b/ld/testsuite/lib/ld-lib.exp
@@ -934,7 +934,7 @@ proc set_file_contents { filename contents } {
 proc ar_simple_create { ar aropts target objects } {
     remote_file host delete $target
 
-    set exec_output [run_host_cmd "$ar" "$aropts rc $target $objects"]
+    set exec_output [run_host_cmd "$ar" "$aropts -rc $target $objects"]
     set exec_output [prune_warnings $exec_output]
 
     if [string match "" $exec_output] then {
@@ -1562,6 +1562,34 @@ proc check_plugin_api_available { } {
     return $plugin_api_available_saved
 }
 
+# Returns true if the target compiler supports LTO
+proc check_lto_available { } {
+    global lto_available_saved
+    global CC
+    if {![info exists lto_available_saved]} {
+	# Check if gcc supports -flto -fuse-linker-plugin
+	if { [which $CC] == 0 } {
+	    set lto_available_saved 0
+	    return 0
+	}
+	set basename "lto"
+	set src ${basename}[pid].c
+	set output ${basename}[pid].so
+	set f [open $src "w"]
+	puts $f ""
+	close $f
+	set status [remote_exec host $CC "-shared -B[pwd]/tmpdir/ld/ -flto -fuse-linker-plugin $src -o $output"]
+	if { [lindex $status 0] == 0 } {
+	    set lto_available_saved 1
+	} else {
+	    set lto_available_saved 0
+	}
+	file delete $src
+	file delete $output
+    }
+    return $lto_available_saved
+}
+
 # Check if the assembler supports CFI statements.
 
 proc check_as_cfi { } {
